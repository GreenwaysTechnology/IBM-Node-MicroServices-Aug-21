					Node.js	
..............................................................................................

Lab:
node
vscode
docker
...........................................................................................

What is Node.js?
 Node.js® is a JavaScript runtime built on Chrome's V8 JavaScript engine.

Java Script Runtime:
 -It is a Runtime to run javascript code.

Types of Javascript Runtime:

1.Embeded javascript Runtime
   The javascript runtime is embeded into browser 
Every WebBrowser has javascript runtime

1.1.Chrome - V8
What is V8?
V8 is Google’s open source high-performance JavaScript and WebAssembly engine, written in C++. It is used in Chrome and in Node.js.

1.2.SpiderMonkey 
	is Mozilla’s JavaScript and WebAssembly Engine, used in Firefox, Servo and various other projects. It is written in C++, Rust and JavaScript. 

1.3.ChakraCore
   Microsoft edge.

etc....

2.Standalone Javascript Runtime.

-V8
..............................................................................................

We have many javascript engine. Can we run javascript code on all javascript engines as it is?

95% is possible.

All javascript engines implements the spec called "ECMA" Specification.

ECMA is standard to define javascript language. 

We call 

ECMA - ES - 1.0
ES 2.0
ES 4.0
ES 5.0
ES 6.0
ES 7....

Most stable version is called -ES 5 AND ES 6
............................................................................................

What is Javascript?

 Javascript is a Programming language
 
 Javascript is object based,functional style, event driven programming language.


Object based vs object oriented:
................................

Object Oriented Principles:
...........................

1.Abstraction
2.Encapsulation
3.Hierarchy
4.Typing
5.Modularity
----------------------
6.Concurrency
7.Persistency


if any language follows all oo concepts, object oriented language.

if any language is not following any one of object oriented principle or paritially implements
that language is called as 'object based language'.


What type of apps you can build using js?
 Object based Language
............................................................................................
functional Programming:
  It is like object oriented programming. 
  It is based on mathmetics called "Lambda calculus".
FP =Lambda calculus

Javascript implements object concepts and functional programming concepts in one place.
Javascript is hybrid style language.
.............................................................................................

Why javascript was created?
  JS created for HTML Document creation,maniupulation  language inside browser :DOM Programming.

When js was created?

In 1996, js was created by Netscap communications.

When js came out for use?

1996 , JS submitted to ECMA Committe.

1997-> JAVA SCRIPT 1.0 -> es 1
es 3 -1999
es 4 -2006
es 5 -2007
es 6 -2012-2015. - ecma 2015
es6 7,8,9....
..............................................................................................

What type of apps i can build using javascript?

-Browser apps - DOM programming
-Server side apps - Web Applications- Node.js
-Mobile Apps 
-IOT Apps

Now javascript is every where.

.............................................................................................
Blocking and Non Blocking Async and Sync Programming:
.....................................................

What is blocking and  non blocking in general?

Blocking means the method/function blocks/pause/freeze the main process until it returns the data to the caller.

Blocking apis will stop the execution until the result is returned to the caller.

Blocking IO AND Non Blocking io?



File Descriptor:
................

-FD is a datastructure presented inside os kernal at very low level
-FD is mapper between os and hardware layer
-FD is entry and exit point of os.


Blocking IO Example: java:

import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;

public class CopyBytes {
    public static void main(String[] args) throws IOException {

        FileInputStream in = null;
        FileOutputStream out = null;

        try {
            in = new FileInputStream("xanadu.txt");
            out = new FileOutputStream("outagain.txt");
            int c;

            while ((c = in.read()) != -1) {
                out.write(c);
            }

	   //some other api call
	    myapi(); // will not be called until read operation and write operation is            completed

        } finally {
            if (in != null) {
                in.close();
            }
            if (out != null) {
                out.close();
            }
        }
    }
}
////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////

Blocking io means:

 Application process is waiting until data is read from the kernal.
 if data is availble inside application only, it will move the next cycle.

eg 
 in.read()| 1.5sec
 otherapi()-this method will be called after 1.5sec only.
............................................................................................

............................................................................................
				Multithreading and Networking
............................................................................................

Multi Threading and IO (Blocking IO):

In General application platforms(jvm,CLR)(process) is multi threaded.

WebServers and Web Containers for any technology(java,.net,python,php) are multi threaded.

Web Containers and Request handling:
...................................

Each Request is mapped with a single thread

Request Per Thread Model

100 request === 100 Threads

Eg:

1.client-1 asks 1 gb file from the web server

 client-----request-----|WebServer----create/use a thread --starts io operations
 client-----request-----|WebServer----create/use a thread --starts io operations
 client-----request-----|WebServer----create/use a thread --starts io operations
 client-----request-----|WebServer----create/use a thread --starts io operations
 client-----request-----|WebServer----create/use a thread --starts io operations
 client-----request-----|WebServer----create/use a thread --starts io operations

Threading Model:

 -  Each Request is assigned to thread

C10k : concurrently handling ten thousand connections

A web server should handle 10k connections at the same point of time(may be 1sc/1min)

C10k is one of the real time problem, expectation was if web server able to handle
10k connections, then it is good infra structure,so i dont need to add more machines.

How to reduce servers , how to utilize the existing hardware resouces.

               "The birth of non blocking technology" / How to reduce threads.


Problems of Multi Threaded Models:

1.Context Switch:
   - if a thread is assigned for a client request, that request takes more time to process.
 thread need to be paused.
    Moving a thread from sleep to running(active) --- active to sleep - ctx switch..

cpu takes much time on thread schduling, so it decreases the performance of the server.

2.memory
   Every thread eats upto 1MB of memory.

............................................................................................


Non Blocking io apis:

In 2000,Linux Operating system started providing, apis in order to perform non blocking io operation.

1.select

2.poll

Select vs poll.

3.epoll
What is epoll?

 Epoll is a program which monitors fd table.
 Fd table is array.
 epoll has a for loop which iterates fd table

 epollfd = epoll_create1(0);

infinit loop
 for(;;){
     read array(fd) entries from 0th index
     checks data availablity from the hardware
     if yes
	 copy data from the hardware to kernal buffer
     else
       move next index
      checks daa availablity from the hardware for 1st index.
    ....
    move until the last index.
   
 }


Steps:

1.thread starts  calling sys call for network io, while doing, it registers a handler function which will be used later by the thread.

2.thread gets control immediately since kernal relases the control

3.Thread starts processing other tasks

Kernal side

1. loop is running by watching fds

2. data is available

3. kernal copies data into buffer

4. kernal emits event

Application

4. Receive events process the event by assigning handler function.

5. Handler function gets called, send data to Caller(user).

.............................................................................................
				How node implements the nonblocking arch
..............................................................................................



Node.js:

-Multi platform(any os), non blocking ,event processing archiecture.
-Reduces more threads,having limited threads-single thread for event processing.
-Suitable for large network concurrency applications.

 1000 requests = 1 thread.
Node components:

V8:


libuv:
  libuv is a multi-platform support library with a focus on asynchronous I/O.
  libuv is collection of c apis for multiple operatings
    -libuv works with epoll in linux
    -libuv works with kqueue in mac/open bsd os
    -libuv works with iocp in windows

Features:

Full-featured event loop backed by epoll, kqueue, IOCP, event ports.
Asynchronous TCP and UDP sockets
Asynchronous DNS resolution
Asynchronous file and file system operations
File system events
ANSI escape code controlled TTY
IPC with socket sharing, using Unix domain sockets or named pipes (Windows)
Child processes
Thread pool
Signal handling
High resolution clock
Threading and synchronization primitives


libuv contains:

1. event loop thread:

  This is demaon thread, starts spinning for listening for incomming events from os kernal space.

2.Thread Pools
   libuv maintains set of threads other than event loop thread for doing "BLOCKING" IO operations.

Warining; 
   dont over use thread pools , because if use more threads from the thread poll then it impacts performance,memory...
   Dont block event loop thread.

////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////
                                NonBlocking and Async implementation
............................................................................................

In order to write non blocking  apps.

 -Language/Platform must provide high level apis
	 -Node provides lot of high level apis 
 -We need to provide listener function/callback function, for handling result

Listener function has two phases:

1.Function must be registered before calling kernal
   Registernation is based on event name.

2.Functions gets called by thread once the event is given

Every listener function is higher order function : Function as parameter.


How javascript /node understands that programs need proceed by event loops thread.
what are blocking api and what are non blocking api.

->All apis are generally blocking except apis which binds with non blocking apis.

eg:
 console.log() - blocking

Node provides non blocking category of apis

1.timers

2.General fs io apis

3.all network api
   http,tcp,udp


All non blockings are powered "handler/callback/listener" functions.

Listener functions are generally higher order function: Passed as parameter.


Non blocking coding Styles:

Note: All are same but just wrappers on top that.

1.callback style /listener

2.Promise style : wrapper for callbacks

3.async functions and await : wrapper for promise.



Common Non Blocking Apis provided by node

1.timers
2.file system apis
3.networking apis
etc....
..........................................................................................
src/index.js

console.log('Hello Node');

how to run?

C:\session\ibm\2021\aug\apps\mynodeapp> node src/index.js
Hello Node

...........................................................................................

Functions declaration,invocation:
//higher order function -  listner pattern

function sayHello() {
    console.log('Hello')
}
sayHello();
//parameters and args

//a and b are args
function add(a = 0, b = 0) {
    return a + b;
}
//1 , 2 are parameters
console.log(add(1, 2))
console.log(add()) //undefined,undefined
/////////////////////////////////////////////////////////////////////////////////////
//Function is first class citzien -  function can be stored inside variable,passed around.

//var ,let ,const - variable declaration

var i = 10; // es 5 style
let j = 100; // es 6 style
const e = 100; // es 6 style

console.log(i, j, e)

i = 900;
j = 89;
// e =900;

console.log(i, j, e)

//anonmous function
let greet = function (name = 'default') {
    console.log('greet', name)
};
greet();
greet('Subramanian')

//arrow function. anonmous function in es 6
let hai = (name = 'default') => {
    console.log('greet', name)
};
hai();

//if function has only one line of body ,we can remove  {}
hai = (name = 'default') => console.log('greet', name);
hai();

//arrow and return

let multiply = (a = 0, b = 0) => {
    return a * b;
}
console.log(multiply(10, 10))

//if function has only one line of body with return statement, we can remove return and {}

multiply = (a = 0, b = 0) => a * b;
console.log(multiply(10, 10))

//one parameter , no default value and return the same. we can remove () and {} and return statement
let echo = message => message

console.log(echo("Hello Echo"))
..............................................................................................

Higher order function:
  function itself is value, so can be passed as parameter to another function that function is called higher order function.

function parameter can be any literal(values).

types of literals

1.string
2.number
3.boolean
4.undefined
5.nan
6.infinity
7.null
8.function
9.object

//Higher order function


function doStuff(a) {
    console.log(a)
}

//we can pass any literal as parameter
doStuff(10)
doStuff("hello")
doStuff(true)
let x = 10;
doStuff(x)
//pass function as parameter

//now connect is higher order
function connect(action) {
    console.log(action);
    action(); //invocation 
}
//pass function as parameter
let myFun = function () {
    console.log('myFun')
}
connect(myFun);

connect(function () {
    console.log('my fun anonmous')
});

//arrow
let myconnect = action => {
    console.log(action);
    action(); //invocation 
};

let myFun1 = () => console.log('myFun-arrow');
myconnect(myFun1);

myconnect(() => console.log('my fun anonmous-arrow'));

..............................................................................................


Advanced Higher order function:


let getMessage = action => {
    action('Hello');
}
getMessage(message => console.log(message));

//complex function

let login = (userName, password, successAction, failureAction) => {
    //logic
    if (userName === 'admin' && password === 'admin') {
        successAction('login success')
    } else {
        failureAction('login failed')
    }
}
login('admin', 'admin', status => { console.log(status) }, err => { console.log(err) })
login('foo', 'bar', status => { console.log(status) }, err => { console.log(err) })

...........................................................................................

How to write blocking code?

//blocking /sequencial code

function sayHello() {
    console.log('hello')
}
function sayHai() {
    console.log('hai')
}
function sayGreet() {
    console.log('greet')
}

sayHello(); 
sayHai();
sayGreet();


How to write non blocking code 

--code will not stop executing next line of code.
-->once result is availble only the function gets called -  callback function/listner function.
--> we need to schudule the code in the background(kernal space)- we need non blocking high level api from js/node.

How to write callback functions?
 -higher order function

Common Non Blocking Apis provided by node

1.timers
2.file system apis
3.networking apis
etc....

1.timers

setTimeout,setInterval,setImmediate...


//non blocking using timer

function blockMe(message) {
    console.log(message);
}
//non blocking function
function delay(action) {
    //high level api to schdule the task in the background
    setTimeout(action, 5000, 'Hello!!!')
}

//
blockMe('start')
delay(response=>console.log(response));
blockMe('end')
blockMe('still going')

callback Programming:
....................

passing function as parameter , gets called after getting event.
............................................................................................
..............................................................................................
					Nested Callbacks
..............................................................................................

 The output of one callback, will be input to another callback.

Use case

 - call getUser api, which returns user if not , throw error.

 - Based on user i need to call login method, if login failed throw error

 - Based on login output, i need to call dashboard

/**
 * getUser--->login--->showPage--->Display result
 * 
 * resolve=SuccessAction
 * reject =FailureAction
 */

const getUser = (resolve, reject) => {
    //logic
    let user = {
        name: 'admin',
        password: 'admin'
    };
    //  user = null;
    let error = {
        code: 500,
        message: 'User not found'
    }
    if (user) {
        setTimeout(resolve, 1000, user);
    } else {
        setTimeout(reject, 1000, error);
    }
}

const login = (user, resolve, reject) => {

    let status = 'login success';
    let error = 'login failed';

    if (user.name === 'admin' && user.password === 'admin') {
        setTimeout(resolve, 1000, status)
    } else {
        setTimeout(reject, 1000, error);
    }
}

const showPage = (status, resolve, reject) => {
    let successPage = 'Welcome to Prime Account';
    let failurePage = 'Welcome to Guest Account'

    if (status === 'login success') {
        setTimeout(resolve, 1000, successPage)
    } else {
        setTimeout(reject, 1000, failurePage)

    }


}

getUser(user => {
    console.log(user)
    login(user, status => {
        console.log(status)
        showPage(status, spage => {
            console.log(spage)
        }, epage => {
            console.log(epage);
        })
    }, err => {
        console.log(err);
    })
}, err => {
    console.log(err)
});


The Problems of Nested Callbacks:
................................

Questions:

1.Whether this code is able to understand quickly
2.Whether this code is able to debug
3.Whehter this code is scalable?
4.whether this code is maintaiable?

fs.readdir(source, function (err, files) {
  if (err) {
    console.log('Error finding files: ' + err)
  } else {
    files.forEach(function (filename, fileIndex) {
      console.log(filename)
      gm(source + filename).size(function (err, values) {
        if (err) {
          console.log('Error identifying file size: ' + err)
        } else {
          console.log(filename + ' : ' + values)
          aspect = (values.width / values.height)
          widths.forEach(function (width, widthIndex) {
            height = Math.round(width / aspect)
            console.log('resizing ' + filename + 'to ' + height + 'x' + height)
            this.resize(width, height).write(dest + 'w' + width + '_' + filename, function(err) {
              if (err) console.log('Error writing file: ' + err)
            })
          }.bind(this))
        }
      })
    })
  }
})

"Callback Hell":
................

 -It is not bug or error in code
 -It is way of writing callback based program
 -Callback based non blocking programming hard to understand,maintain,debug,scale Which 
  called as "Callback Hell".

How to write better async/non blocking code without writings callbacks?

-Generally without callbacks not possible to write async/non blocking code.
-Rather we can abstract complexity of writting callbacks.

In 2005, JQUERY team started with working complex callback patterns, they found callback hell problem.

They proposed a  Design pattern to write better callback programming(Async) programming.

  "Promise".

Promise is design pattern which hides complexity of callback patterns


Since Promise is design pattern, many people have implemented Promise design pattern.

1.JQuery -first promise implementation
2.many libs and frameworks


...........................................................................................

In order standarize , ECMA committe decided to include Promise Design pattern at language level .(ES 6)
2012 E6 Commit introduced promise design pattern  as  "Promise" Object  in javascript.



Promises and non blocking,async and callback hell issues:
.........................................................

features of Promise Object:

1.Promise by deafult is Async. Which implements timer api with 0 ms .

Promise can be used with any async callback based  implementations.


Objective:

 To remove callbacks in async/non blocking code. write cleaner async programming.
 To remove complex callback chaining code.
.............................................................................................


Promise Implemenation:How to create Promise Object

1. Create Promise Object from Promise contructor -  new Promise()
2. Create Promise object from factory apis       - Promise.resolve(), Promise.reject()

Promise object methods:
1.then - success
2.catch - errors
3.finally - clean up
factory api to create Promise object
4.resolve
5.reject
.......................................
6.all
7.race

............................................................................................

Promise with only success 

//Promise : How to create Promise Object, how to subscribe the 

function blockMe(message) {
    console.log(message);
}

//factory pattern
function getSuccess(){
    return Promise.resolve('Success');  // Promise Object with setTimeout of 0ms
}

blockMe('start')
// let mypromise= getSuccess()
// mypromise.then(res=>console.log(res))
getSuccess()
 .then(res=>console.log(res))
blockMe('end')
..............................................................................................
Catch Error:

//Promise : How to create Promise Object, how to subscribe the 

function blockMe(message) {
    console.log(message);
}

//factory pattern
function getFailure(){
    return Promise.reject('Something Went Wrong');  // Promise Object with setTimeout of 0ms
}

blockMe('start')
getFailure()
 .catch(err=>console.log(err))
blockMe('end')
.............................................................................................

How to handle success and failure based on biz logic.

const login = (userName, password) => {
    if (userName === 'admin' && password === 'admin') {
        return Promise.resolve('Login Success');
    } else {
        return Promise.reject('Login Failed')
    }
}

login('admin', 'admin')
    .then(res => console.log(res))
    .catch(err => console.log(err));
login('foo', 'admin')
    .then(res => console.log(res))
    .catch(err => console.log(err))

.............................................................................................
Promise with Constructor Pattern:

When we can select Constructor pattern?

-if i want to convert existing callback based code into promise 
-Incase if you are using timer with explicit timeout like 1000,5000 -  i want use setTimeout

new Promise()
     |
  constructor call

eg :

function Employee(){} - es 5 classes

class Employee {} -  es 6 class Syntax 

new Employee()
new Product()

Promise Constructor takes parameter which is function.

Parameter function takes two args 
 first arg represents success(resolve)
 second arg represents failure(reject)

new Promise(function(resolve,reject) {
  //function body - logic
   
})

function body has logic which is async code.

new Promise(function(resolve,reject) {
  //function body - logic
   setTimeout(resolve,5000,'data')
})

new Promise((resolve,reject)=> {
  //function body - logic
   setTimeout(resolve,5000,'data')
})
...........................................................................................

//promise constructors

function blockMe(message) {
    console.log(message);
}
function delay() {
    return new Promise((resolve, reject) => {
        setTimeout(resolve, 5000, 'Success Info')
    });
}

blockMe('start')
delay()
  .then(res=>console.log(res))
  .catch(err=>console.log(err));
blockMe('end')
.............................................................................................

PromiseConstructors with biz logic:

const login = (userName, password) => {
    return new Promise((resolve, reject) => {
        if (userName === 'admin' && password === 'admin') {
            setTimeout(resolve, 5000, 'Login success')
        } else {
            setTimeout(reject, 5000, 'Login Failed')
        }
    })


}

login('admin', 'admin')
    .then(res => console.log(res))
    .catch(err => console.log(err));
login('foo', 'admin')
    .then(res => console.log(res))
    .catch(err => console.log(err))
.............................................................................................

how to fix Callback hell using promises?


const getUser = () => {

    console.log('get user is called')
    //logic
    let user = {
        name: 'admin',
        password: 'admin'
    };
    //  user = null;
    let error = {
        code: 500,
        message: 'User not found'
    }
    return new Promise((resolve, reject) => {
        if (user) {
            setTimeout(resolve, 1000, user);
        } else {
            setTimeout(reject, 1000, error);
        }
    })
}

const login = user => {
    console.log('login is called')

    let status = 'login success';
    let error = 'login failed';
    return new Promise((resolve, reject) => {
        if (user.name === 'admin' && user.password === 'admin') {
            setTimeout(resolve, 1000, status)
        } else {
            setTimeout(reject, 1000, error);
        }
    });

}

const showPage = (status) => {
    console.log('show page is called')

    let successPage = 'Welcome to Prime Account';
    let failurePage = 'Welcome to Guest Account'
    return new Promise((resolve, reject) => {
        if (status === 'login success') {
            setTimeout(resolve, 1000, successPage)
        } else {
            setTimeout(reject, 1000, failurePage)

        }
    });
}

// getUser(user => {
//     console.log(user)
//     login(user, status => {
//         console.log(status)
//         showPage(status, spage => {
//             console.log(spage)
//         }, epage => {
//             console.log(epage);
//         })
//     }, err => {
//         console.log(err);
//     })
// }, err => {
//     console.log(err)
// });

// getUser()
//     .then(user => {
//         console.log(user)
//         login(user)
//             .then(status => {
//                 console.log(status)
//                 showPage(status)
//                     .then(spage => {
//                         console.log(spage)
//                     })
//                     .catch(epage => console.log(epage))
//             })
//             .catch(err => console.log(err))
//     })
//     .catch(err => console.log(err));

//The refactored promise code.

// getUser()
//     .then(user => {
//         console.log(user);
//         return login(user)
//     })
//     .then(status => {
//         console.log(status)
//         return showPage(status);
//     })
//     .then(page => {
//         console.log(page);
//     })
//     .catch(err => console.log(err));

//Es6 refactoring

getUser()
    .then(user =>login(user))
    .then(status =>showPage(status))
    .then(page =>console.log(page))
    .catch(err => console.log(err));
............................................................................................
				async and await
.............................................................................................

async and await are keywords to simplify promise handling -  without "thenables"

If code grows with many promises, you can see more "thenables",Which leads the problem called
"Promise Hell".

Promise Hell:

 In large code base, you can see many "thenables", how to reduce thenables.

ES 7 introduced even simple keywords , looks like sync program/sequencial call.
			"Sync style of async programm"

"async function and await keyword".



function delay() {
    return new Promise((resolve, reject) => {
        setTimeout(resolve, 1000, 'Hello!');
    })
}

//delay()

async function main() {
    //    delay()
    //     .then(res=>console.log(res))

    try {
        const res = await delay();
        console.log(res);
    } catch (err) {
        console.log(err);
    }

}
main();
.............................................................................................
Complex async and await:


const getUser = () => {

    console.log('get user is called')
    //logic
    let user = {
        name: 'admin',
        password: 'admin'
    };
    //  user = null;
    let error = {
        code: 500,
        message: 'User not found'
    }
    return new Promise((resolve, reject) => {
        if (user) {
            setTimeout(resolve, 1000, user);
        } else {
            setTimeout(reject, 1000, error);
        }
    })
}

const login = user => {
    console.log('login is called')

    let status = 'login success';
    let error = 'login failed';
    return new Promise((resolve, reject) => {
        if (user.name === 'admin' && user.password === 'admin') {
            setTimeout(resolve, 1000, status)
        } else {
            setTimeout(reject, 1000, error);
        }
    });

}

const showPage = (status) => {
    console.log('show page is called')

    let successPage = 'Welcome to Prime Account';
    let failurePage = 'Welcome to Guest Account'
    return new Promise((resolve, reject) => {
        if (status === 'login success') {
            setTimeout(resolve, 1000, successPage)
        } else {
            setTimeout(reject, 1000, failurePage)

        }
    });
}

async function main() {
    // getUser()
    // .then(user =>login(user))
    // .then(status =>showPage(status))
    // .then(page =>console.log(page))
    // .catch(err => console.log(err));

    try {
        const user = await getUser();
        const status = await login(user);
        const page = await showPage(status);
    }
    catch(err){
        console.log(err);
    }

}
main()
.............................................................................................
					Modularity:
.............................................................................................

What is Modularity?
  Breaking application into smaller units.

Types of Modularity?

1.Physicall modularity
  
  folders,files :  code is kept/organized into files and folders

2.Logical modularity
  code is kept into classes,functions,objects

Java:

 folders/files
  com/ibm/util/Utility.java

 package com.ibm.util

 class Utility{

 }



What about javascript Modularity?

1.Physicall modularity
   fodlers/file based
   scripts/index.js
2.logical modularity
  js does not offer logical modularity at language level.

Once js started growing in large scale, dev struck to organize code.

2000, Smart developers started thinking about how to modualrize js code.

Module design patterns came.

1.Namespace design pattern : 2000 : jquery implemented this design pattern in 2005
2.AMD -Async Module Defintion : dojo implemented amd design pattern 
---------------------------------------------------------
3.CJS - Common JS =  namespace + amd -2005
4.ES 6 Module design pattern  = amd + cjs - 2012 ECMA Committe introduced this pattern
------------------------------------------------------------
5.System = AMD = CJS + ES 6
6.UMD = NAMESPACE + AMD + CJS + ES 6


only two design patterns are used in development

1.CJS - Common JS =  namespace + amd
2.ES 6 Module design pattern  = amd + cjs

CJS ; implemented inside node js. node supports commonjs by default.

I can organize the code , based on these patterns, but what about runtimes?

  js runtime never suppport these patterns directly 
  each design pattern is lib.

 Loaders : it is simple js lib to help link and load js files.

Node.js has built in cjs loader and linker, so we dont need to install loaders
Browers has no built in support for any modular design pattern natively except , namespace.

////////////////////////////////////////////////////////////////////////////////////////////
				COMMONJS - Nodejs
////////////////////////////////////////////////////////////////////////////////////////////

Two important task in modules:

1.how to link files

  We need loaders and linkers - node.js provides by default
eg
java : import 

cjs : require('fileNametoBelinked')

Use case 1 : how to link files 

src/mylib.js
console.log('mylib')

src/index.js
const res = require('./mylib')

$node src/index.js
mylib


2.how to share code

What is code , What code can be shared to other files.

code : collection of variables,functions,classes,objects,arrays.

Ways of code sharing:

1.Pack the code into one object(literal) which you want to share

-exports
   -used to share code in form of object
   -code is packed inside object and shared that object
-module.exports
   -used to share code as it is.




src/mycode.js

//share code : variables having any value,functions,classes,objects,arrays

//pack the code into object using exports keyword
//exports.variable =value

exports.firstName = 'Subramanian'
exports.lastName = 'Murugan';
exports.age = 40
exports.isActive = true;
exports.calculate = function () {
    return 10;
}
exports.skills = ['javascript', 'node', 'java'];
exports.address = {
    city: 'Coimbatore',
    state: 'Tamil Nadu'
}

src/index.js
const info = require('./mycode')
console.log(info);

console.log(info.firstName,info.lastName,info.age)
console.log(info.address.city,info.address.state)
console.log(info.skills)
console.log(info.calculate())
..........................................................................................
module.exports:
..............

   -used to share code as it is.

When to use module.exports?

-to share single class
-to share single function
-to share single array
-to share any single variable,object



src/greeter.js


class Greeter {
    constructor() {

    }
    sayHello(name = '') {
        return `Hello ${name}`
    }
}

//share the class
module.exports = Greeter;

src/index.js
const Greeter = require ('./greeter');
console.log(Greeter)

let greet = new Greeter();

console.log(greet.sayHello('Subramanian'))
..............................................................................................

Returning object 


const Greeter = require ('./greeter');
const product = require('./product')

console.log(Greeter)

let greet = new Greeter();

console.log(greet.sayHello('Subramanian'))
console.log(product.findAll())

src/product.js


class Product {
    constructor(){
    
    }
    findAll(){
        return 'products'
    }
}

module.exports = new Product();
..............................................................................................

folders and file structures:
.............................

Objective:
 Build api

src
 |
 services
 mock-data
 app.js


src/services/todo.service.js
const TODOS = require('../mock-data/todo')

class TodoService {
    constructor() {

    }
    //sync api
    findAll() {
        return TODOS;
    }

    findAllAsyncCb(callback) {
        setTimeout(callback, 5000, TODOS);
    }

    findAllAsyncPromise() {
        return new Promise((resolve, reject) => {
            setTimeout(resolve, 5000, TODOS);
        })
    }

    getCompletedTodos() {
        return TODOS.filter(todo => todo.completed)
    }
}
module.exports = new TodoService();

src/app.js
const todoservice = require('./services/todo.service');


async function main() {
    //console.log(todoservice.findAll());
    // console.log(todoservice.getCompletedTodos())
    // console.log('start')
    //  todoservice.findAllAsyncCb(todos=>{
    //      console.log(todos);
    //  })
    // todoservice.findAllAsyncPromise()
    //     .then(todos => console.log(todos));

    const todos = await todoservice.findAllAsyncPromise();
    console.log(todos);
    // console.log('end')
}
main();

src/mock-data/todo.js

please refer code 
..............................................................................................
//////////////////////////////////////////////////////////////////////////////////////////////						Node.js api modules
..............................................................................................


Types of modules:

1.Custom modules
  built by us
2.Built in modules
   provided by node.js  
3.Third party modules-Provided by third party/community
  libs,frameworks -eg React,angular,Vue,express,jquery..............
..............................................................................................
Node js Built in modules:
.........................

-os
-events
-fs
-http
............................................................................................

1.os 

The os module provides operating system-related utility methods and properties. It can be accessed using:
const os = require('os');

console.log(os.arch());
console.log(os.cpus());


const { arch, cpus } = require('os');
console.log(arch());
console.log(cpus());
..............................................................................................
Object destrucing:
..................

//object destructuring: es 6 feature

// function printEmployee(employee) {
//  console.log(`Id ${employee.id}`)
//  console.log(`Name ${employee.name}`)
//  console.log(`City ${employee.address.city}`)
// }
// function printEmployee(employee) {
//     //destructuring syntax
//     const { id, name, address } = employee;
//     console.log(`Id ${id}`)
//     console.log(`Name ${name}`)
//     console.log(`City ${address.city}`)
// }

// function printEmployee({ id, name, address }) {
//     console.log(`Id ${id}`)
//     console.log(`Name ${name}`)
//     console.log(`City ${address.city}`)
// }

// const printEmployee = ({ id, name, address }) => {
//     console.log(`Id ${id}`)
//     console.log(`Name ${name}`)
//     console.log(`City ${address.city}`)
// }
const printEmployee = ({ id, name, address: { city } }) => {
    console.log(`Id ${id}`)
    console.log(`Name ${name}`)
    console.log(`City ${city}`)
}

printEmployee({ id: 1, name: 'Subramanian', address: { city: 'Coimbatore' } })



class EmployeeService {
    findAll() {
        return 'findall';
    }
}
let empService = new EmployeeService();
console.log(empService.findAll());


let { findAll } = new EmployeeService();
console.log(findAll());
............................................................................................

./ vs ''(without ./)
.........

 require('./services/TODOService');
  ->here you can see ./
  ./ -current dir

 require('os'); => 
  -here no ./ 

Why?

Note : if you are java devp, you know the classpath , how it works?


require('os');

Node internally uses a search algorthim,node always looks the folder called
 "node_modules" in the current project, if not , then it searches, the node in built 
installtion folder---c:/pf/node/node_modules--if it finds it will pick up from there else it will throw error.

require('./services/TODOService');
   it will lookup in the current dir or sub dirs only.

nternal/modules/cjs/loader.js:800
    throw err;
    ^

Error: Cannot find module 'osxx'
Require stack:
- C:\session\ibm\feb\nodems\mynodeapps\src\index.js
[90m    at Function.Module._resolveFilename (internal/modules/cjs/loader.js:797:15)[39m
[90m    at Function.Module._load (internal/modules/cjs/loader.js:690:27)[39m
[90m    at Module.require (internal/modules/cjs/loader.js:852:19)[39m
[90m    at require (internal/modules/cjs/helpers.js:74:18)[39m
    at Object.<anonymous> (C:\session\ibm\feb\nodems\mynodeapps\src\index.js:1:32)
[90m    at Module._compile (internal/modules/cjs/loader.js:959:30)[39m
[90m    at Object.Module._extensions..js (internal/modules/cjs/loader.js:995:10)[39m
[90m    at Module.load (internal/modules/cjs/loader.js:815:32)[39m
[90m    at Function.Module._load (internal/modules/cjs/loader.js:727:14)[39m
[90m    at Function.Module.runMain (internal/modules/cjs/loader.js:1047:10)[39m {
  code: [32m'MODULE_NOT_FOUND'[39m,
  requireStack: [ [32m'C:\\session\\ibm\\feb\\nodems\\mynodeapps\\src\\index.js'[39m ]
.............................................................................................
//////////////////////////////////////////////////////////////////////////////////////////
				Event Emitter - Events Module
..........................................................................................


Node is Event Driven Platform. Node programs works based on events.

Generally events are published by os kernal, event loop thread process those events.

We(program) can publish events(custom events), Program can listen for those events.

Types of Events:

1.Kernal Events - Timer,IO,network Events
2.Application Events -  events published and consumed by application itself.

Application Events:
...................

Event Emitter Module: events

   Much of the Node.js core API is built around an idiomatic asynchronous event-driven architecture in which certain kinds of objects (called "emitters") emit named events that cause Function objects ("listeners") to be called.

Roles:

1.Emitter 
    Emitter emits events
2.Listener
    Listener listens

Use case : we create object who acts listener and emitter.
const EventEmitter = require('events');

//declare class which inherits EventEmitter

class CustomerService extends EventEmitter {

    constructor() {
        super();
        //listener registration
        this.on('sales', (evt) => {
            console.log('We got Event');
            console.log(evt)
        })
    }
    //biz methods
    buy(product) {
        //emit event.
        this.emit('sales', product);
    }
}
//create object
const custService = new CustomerService();
custService.buy({ id: 1, name: 'Phone', price: 1000, qty: 1 })
.............................................................................................
...........................................................................................
					IO
				   (File System IO) :Hard disk
............................................................................................
Node was built for performning non blocking io / async io.

What if i want to write blocking io is it Possible?

 Yes!

Node supports FS blocking io operations.

File System:fs

-used to read , write into and from disk.

mode :

  - sync /blocking 
  - async/ non blocking

based on data read/write:

 -non streaming
 -streaming


const fs = require('fs');

const filePath = './src/assets/info.txt';
const options = {
    encoding: 'UTF-8'
}

function block(message) {
    console.log(message)
}

block('start')
fs.readFile(filePath, options, (err, data) => {
    if (err) throw err;
    console.log(data);
});
block('end')

..............................................................................................

Blocking IO Operations: 

-Node allows blocking io operations
-Blocking io will block the current event loop thread.
-In order to optimize , the event loop thread does not perform real io calls,Node provides
 a separate thread  called "Worker pool thread" 

const fs = require('fs');

const filePath = './src/assets/info.txt';
const options = {
    encoding: 'UTF-8'
}

function block(message) {
    console.log(message)
}

block('start')
//blocking api
const data = fs.readFileSync(filePath, options)
console.log(data);
block('end')
/////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////

How to write data into file async:

const fs = require('fs');

const filePath = './src/assets/infowrite.txt';
const options = {
    encoding: 'utf-8'
}
const data = 'Hello,How are you';

fs.writeFile(filePath, data, options, err => {
  if (err) throw err;
  console.log(`data has been written into ${filePath}`)
})
////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////

const fs = require('fs')
const path = require('path');

//node global variables
// console.log(__dirname)
// console.log(__filename)

const filePath = path.join(__dirname,'assets/infowrite.txt')
const options = {
    encoding: 'utf-8'
}
const data = 'Hello,How are you';

fs.writeFile(filePath, data, options, err => {
  if (err) throw err;
  console.log(`data has been written into ${filePath}`)
})
.............................................................................................
				Promises and file System apis
const fs = require('fs');

src/services/file.service.js

class FileService {
    constructor() {

    }
    readFile(filePath, options) {

        return new Promise((resolve, reject) => {
            fs.readFile(filePath, options, (err, data) => {
                if (err) {
                    reject(err)
                }
                resolve(data);
            })
        })

    }
}

module.exports = new FileService();

const { readFile } = require('./services/file.service');
const path = require('path');

src/index.js

async function main() {
    const filePath = path.join(__dirname, 'assets/info.txt')
    const options = {
        encoding: 'utf-8'
    }
    // fileService.readFile(filePath, options)
    //     .then(res => console.log(res))
    //     .catch(err => console.log(err))

    try {
        const data = await readFile(filePath, options);
        console.log(data);
    }
    catch (err) {
        console.log(err)
    }
}
main();
..............................................................................................
..............................................................................................
				Event driven IO : Streaming
..............................................................................................



if you want to read or write from file or socket , you can do in two ways

1.Non streaming:
   only file io is supported, network io not supported

-once file is read, the entire is loaded into node process buffer(memory), then it will be delivered to caller.

-if more files are loaded into node process, node process gets crashed.

-non streaming mode is not suitable for large and big files read or write operation.

fs.readFile() and fs.writeFile are non streaming apis.

2.streaming:
   supported by fs and also network apis



-Streaming is nothing but flow of data(chunks).
-Streaming allows move the data from one place to another place one by one.
-Streaming apis are other wise called evented io. which is powered events.


Types of Streams:

1.Readable Stream : input
2.Writeable stream : output
3.Duplex stream : read + write

Node has lot of built in stream apis
....................................

Built in readable Streams:

-HTTP responses, on the client
-HTTP requests, on the server
-fs read streams
-zlib streams
-crypto streams
-TCP sockets
-child process stdout and stderr
-process.stdin

Writable Streams:

-HTTP requests, on the client
-HTTP responses, on the server
-fs write streams
-zlib streams
-crypto streams
-TCP sockets
-child process stdin
-process.stdout, process.stderr


All streaming apis are powered with events
node io streams has built in events.
events are emitted by node.
Our programs are listeners

Common events in all io
.........................


1.data event:
 which is emitted by node, for each chunk.

2.close event:
  The 'close' event is emitted when the stream and any of its underlying resources (a file descriptor, for example) have been closed.

3.end event:
 The 'end' event is emitted when there is no more data to be consumed from the stream.

3.Event: 'error'
 The 'error' event may be emitted by a Readable implementation at any time
Typically, this may occur if the underlying stream is unable to generate data due to an underlying internal failure, or when a stream implementation attempts to push an invalid chunk of data.


const fs = require('fs');
const path = require('path');

const fileName = path.join(__dirname, 'assets/info.txt');
const options = {
    encoding: 'UTF-8'
}

const inputStream = fs.createReadStream(fileName, options);

//listen for event

//data event is emitted by os for each chunk of data
let data = ''
inputStream.on('data', chunk => {
    console.log(`Received ${chunk.length} bytes of data.`)
    data += chunk;
})
//end event is called , no more chunk of data is availble.
inputStream.on('end', () => {
    console.log('There will be no more data to read!');
    console.log(data);
})

//error event: for error handling
inputStream.on('error', err => {
    console.log(`Some thing went wrong! ${err}`)
});
.............................................................................................

const fs = require('fs');
const path = require('path');
const { log } = console;

const fileName = path.join(__dirname, 'assets/big.file');
const config = {
    encoding: 'UTF-8'
}
const inputStream = fs.createReadStream(fileName, config);

//data event is emitted by os for each chunk of data
let data = ''
inputStream.on('data', chunk=> {
    log(`Received ${chunk.length} bytes of data.`)
    data += chunk;
})

//end event is called , no more chunk of data is availble.
inputStream.on('end', () => {
    log('There will be no more data to read!');
    log(data);
})

//error event: for error handling
inputStream.on('error', err => {
    log(`Some thing went wrong! ${err}`)
});
..............................................................................................
/////////////////////////////////////////////////////////////////////////////////////////////
				BackPressure
.............................................................................................


Backpressure:
Problems when you do read and write together

1. In general read operation is faster than write operation


Back Pressure means inputstream is fast, outputstream slow, then data will be
lost.


How to handle back pressure?

 apis  : pause,resume
	 drain event

pause : to close the upstream, not to emit data
resume : to open the open upstream , to emit data

drain event: if drain event is called.


const fs = require('fs');
const path = require('path');

const inputfileName = path.join(__dirname, 'assets/big.file');
const outputfileName = path.join(__dirname, 'assets/bigcopy.file');

const config = {
    encoding: 'UTF-8'
}

//Back pressure handling
const readerStream = fs.createReadStream(inputfileName, config);
const writeStr = fs.createWriteStream(outputfileName, config);

readerStream.on('data', function (chunk) {
    console.log(`Received ${chunk.length} bytes of data.`);
    let buffer_good = writeStr.write(chunk);
    if (!buffer_good) readerStream.pause();
});

writeStr.on('drain', function () {
    console.log('buffer drained!');
    readerStream.resume();
});
readerStream.on('end', function () {
    //console.log(data);
});

readerStream.on('error', function (err) {
    console.log(err.stack);
});
.............................................................................................

Back Pressure using Pipe Method:

const fs = require('fs');
const path = require('path');

const inputfileName = path.join(__dirname, 'assets/big.file');
//write
const outputFileName = path.join(__dirname, 'assets/bigcopy.file');

const config = {
      encoding: 'UTF-8'
}

//Back pressure handling
const readerStream = fs.createReadStream(inputfileName, config);
const writeStr = fs.createWriteStream(outputFileName, config);

//backPressure streams
//pipe method is simplest method which wraps resume,pasuse,drain 
readerStream.pipe(writeStr);
.............................................................................................

..............................................................................................
			        HTTP Programming
.............................................................................................

How to build non blocking webservers and webapps?

You can create webservers and on which you can deploy apps, unlike traditional webserver model
where webserver is separate, and app is different.

Node invented for building network io applications.

Network implementation in non blocking:

HTTP module is used to build http server,app, deployment


HTTP modules objects:


1.Server
  Server object is used to implement http servers/web containers
2.ServerResponse
  Object is used to send data 
3.ClientRequest
   Request object is used to handle http client requests
4.IncommingMessage
   Represents message payloads.


Note: all http implemnetation is streaming powered by default.


Steps:

1.create Server.
2.request-response handling
3.starting server



const http = require('http');

//create server and handle client request

const server = http.createServer((req, res) => {
      res.write('Hello Node HTTP server')
      res.end();
})

//start webserver
server.listen(3000,()=>{
    console.log(`HTTP Server is Running`);
});
//////////////////////////////////////////////////////////////////////////////////////////

HTTP Events:
-response events
-request events
-server events

const http = require('http');

//create server and handle client request

const server = http.createServer((req, res) => {
    res.write('Hello Node HTTP server')
    res.end();
    //attach response events
    res.on('close', () => {
        console.log('response closed')
    })
    res.on('finish', () => console.log('response finish event is called'))

})

//start webserver
server.listen(3000, () => {
    console.log(`HTTP Server is Running`);
});

//server events
server.on('request', (req, res) => {
    console.log('New Request has come ' + new Date())
});
............................................................................................

How to read data from client?
const http = require('http');

//create server and handle client request

const server = http.createServer((req, res) => {

    let data = '';
    req.on('data', chunk => {
        data += chunk
        console.log(data);
    });
    req.on('end',()=>{
        res.write(data)
        res.end();
    })
    //attach response events
    res.on('close', () => {
        console.log('response closed')
    })
    res.on('finish', () => console.log('response finish event is called'))

})

//start webserver
server.listen(3000, () => {
    console.log(`HTTP Server is Running`);
});

//server events
server.on('request', (req, res) => {
    console.log('New Request has come ' + new Date())
});
..............................................................................................

How to send Json?

const http = require('http');
const TODOS = require('./mock-data/todo');

//create server and handle client request

const server = http.createServer((req, res) => {

    res.writeHead(200, {
        'Content-Type': 'application/json'
    })
    res.write(JSON.stringify(TODOS));
    res.end();
    //attach response events
    res.on('close', () => {
        console.log('response closed')
    })
    res.on('finish', () => console.log('response finish event is called'))

})

//start webserver
server.listen(3000, () => {
    console.log(`HTTP Server is Running`);
});

//server events
server.on('request', (req, res) => {
    console.log('New Request has come ' + new Date())
});

.............................................................................................
const http = require('http');
const { findAllAsyncPromise } = require('./services/todo.service');

const server = http.createServer(async (req, res) => {
    // findAllAsyncPromise()
    //     .then(todos => {
    //         res.writeHead(200, {
    //             'Content-Type': 'application/json'
    //         })
    //         res.write(JSON.stringify(todos))
    //         res.end();
    //     })
    //     .catch(err => {
    //         res.writeHead(200, {
    //             'Content-Type': 'application/json'
    //         })
    //         res.write(JSON.stringify({ message: 'Todos not found' }))
    //         res.end();
    //     })

    try {
        const todos = await findAllAsyncPromise();
        res.writeHead(200, {
            'Content-Type': 'application/json'
        })
        res.write(JSON.stringify(todos))
        res.end();

    }
    catch (err) {
        res.writeHead(200, {
            'Content-Type': 'application/json'
        })
        res.write(JSON.stringify({ message: 'Todos not found' }))
        res.end();
    }

})

//start webserver
server.listen(3000, () => {
    console.log(`HTTP Server is Running`);
});

//server events
server.on('request', (req, res) => {
    console.log('New Request has come ' + new Date())
});
//////////////////////////////////////////////////////////////////////////////////////////////

HTTP Method Mapping -GET,POST,DELETE,PUT
HTTP URI Pattern to Match Resources -  /api/customers ,/api/customers/id

if you want to build restfull applications using http module alone is very complex , because we need to take care of method mapping,url mapping and biz logic.

so we need framework /lib to abstract away all complex  work flows- just focus biz logic.

That is birth of http frameworks from node js - express.js,happi.js,loopback


if i want to use any lib/framework inside node , we need to learn one more concept- NPM

..............................................................................................
				  NPM - Node Package Manger
..............................................................................................


npm is tool is used to distribute node modules to others
and you can get node modules from other others.

npm tool is distributed along with node installation

npm uses public repository server called npmjs.com npmjs.org

tools and libs,frameworks all are distributed as node modules into repository.
..............................................................................................
				Javascript Apps


Javascripts apps could be server-side apps like web apps,webservices,microservices, client side apps angular,react,vue, mobile apps ......

There is common structure which is defined by npm.

The Project will have 

1.package.json file
   meta file which describes the project information
2.node_modules folder
  which contains libs/frameworks/tools code.

From where we can get libs/frameworks code?
  We have repository npmjs.com

create package.json file

>npm init

{
  "name": "nodeapps",
  "version": "1.0.0",
  "description": "This is node and npm project",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "author": "",
  "license": "ISC"
}
..............................................................................................
package Types:

1.public package
  react
2.private package 
  @angular - @-npm private 


npm is used

to install,uninstall,publish node modules from node repo / into node repo.

if you install third party modules , into your project, node distributes npm tool ,using this you can install,uninstall,upgrade node modules.
.............................................................................................
npm is used

to install,uninstall,publish node modules from node repo / into node repo.

if you install third party modules , into your project, node distributes npm tool ,using this you can install,uninstall,upgrade node modules.
.............................................................................................



installing module:

>npm install  moduleName  --options
>npm i moduleName --options


>npm install module 
  here no option is told, means default option is --save
>npm i module

options:
 --save 
 --save-dev
 --production
 -g

How to install lodash?

npm install lodash --save
npm install lodash 

Types of Software Dev:

1.Development
2.Testing
3.Production

During dev, if you are using unit testing libs in case of java - junit.jar, but i dont need junit.jar in production env.

if you are using jdbc drivers, necessary in dev and production.

--save : 
   if you install any module with this flag, meaning that module should be used dev and production - both env

--save-dev
   if you install any module with this flag, meaning that module should be used only in dev cycle.

--production
    if you install with this flag, during application packing , all --save-dev modules will be removed.

-g :
   global modules- which is not installed inside project/app as dependancy.
  tools,cli ,compilers,webservers.....


How to use lodash?


npm i --save lodash

package.json

{
  "name": "mynodeapp",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "author": "",
  "license": "ISC",
  "dependencies": {
    "lodash": "^4.17.21"
  }
}

index.js
const _ = require('lodash')

console.log(_.sum([1,2,3]))
.............................................................................................
Development only dependency:

--save-dev

What could be dev only dependency?

-Unit Testing libs and frameworks
-compilers
-tools
-build systems like webpack

Unit Testing libs and frameworks:

-chai

npm i chai --save-dev

{
  "name": "mynodeapp",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "author": "",
  "license": "ISC",
  "dependencies": {
    "lodash": "^4.17.21"
  },
  "devDependencies": {
    "chai": "^4.3.4"
  }
}
..........................................................................................

How to move the app to production?

-should not move your app with dev dependencies
-should copy the application with node_modules folder
-should copy only the app code and package.json file

How to do that?

-Using npm tool itself
-Using build tools like web pack,rollpack.


-Using npm tool itself

npm install --production
 - if you run this command, npm will skip entries from "devdependencies".
.............................................................................................

Global Modules:

npm install module -g --global

npm i module -g


Why Global Modules:

 -Tools
   compilers,webservers,build tools,testing runtime, framework runtime, cli tools for project    creations.

C:\Users\sasub\AppData\Roaming\npm -- here only all global modules will be installed.

Demo:
....

npm install module-name(tool) -g

mocha : unit testing framwork, is used to run java script unit testing on node and browser.

npm install --global mocha

mocha : unit testing framwork, is used to run java script unit testing on node and browser.

npm install --global mocha
npm install -g mocha
Steps:

create test folder
 test
create spec file
test
  -demo.spec.js
var assert = require('assert');
describe('Array', function() {
  describe('#indexOf()', function() {
    it('should return -1 when the value is not present', function() {
      assert.equal([1, 2, 3].indexOf(4), -1);
    });
  });
});

var assert = require('chai').assert
  , foo = 'bar'
  , beverages = { tea: [ 'chai', 'matcha', 'oolong' ] };

assert.typeOf(foo, 'string'); // without optional message
assert.typeOf(foo, 'string', 'foo is a string'); // with optional message
assert.equal(foo, 'bar', 'foo equal `bar`');
assert.lengthOf(foo, 3, 'foo`s value has a length of 3');
assert.lengthOf(beverages.tea, 3, 'beverages has 3 types of tea');

C:>mocha


  Array
    #indexOf()
      √ should return -1 when the value is not present


  1 passing (8ms)
............................................................................................................................................................................................
				Automation
.............................................................................................

How to use javascript for automation?


We can automate js applications.

write all auotomation steps inside scripts

 "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  }


How to run node applications?

1.node folderName/filename.js

2.npm start
via script
how to run script

>npm commandname ---incase of built in command
>npm start

>npm run commandname - custom commands
>npm run subu

  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "start" : "node src/app.js",
    "subu"  :"node src/app.js "
  },

npm test
npm start
npm run subu
.......................................................................................//////////////////////////////////////////////////////////////////////////////////////////////	
				Scripts and Global Module
..............................................................................................

Scripts and Global Module:

-Global modules are used for tooling purpose like compilers,build tools,servers,test runners(mocha).

Globals has some issues:

1.version and compablity issue for new projects



Steps:

1.npm uninstall mocha -g

2.>mocha --help
'mocha' is not recognized as an internal or external command,
operable program or batch file.

3.install mocha locally

 npm install mocha --save-dev

4.>mocha
'mocha' is not recognized as an internal or external command,
operable program or batch file.

Why i am getting error?
  because mocha is command, we cant run directly.

5.solution is run via scripts

package.json
"scripts": {
    "test": "mocha",
    "start": "node src/index.js",
    "subu": "node src/index.js"
  }

npm test

> nodeapps@1.0.0 test C:\session\ibm\2021\june\nodemicroservices\nodeapps
> mocha



  Array
    #indexOf()
      √ should return -1 when the value is not present


  1 passing (6ms)
..............................................................................................
				  Third Party Module
			        Frameworks - Express.js
..............................................................................................



How to build enterprise node apps?

Frameworks:

Web Apps:

1.Express.js

Fast, unopinionated, minimalist web framework for Node.js

express is built on top of http core module.



What apps can be built using express?


1.RESTFull WebServices

2.Dynamic content generation apps -  spring mvc, .netmvc.   with ui


Core features of Express:

1.Abstraction on core http module
2.lot of apis to send data like json api
3.routers : to create HTTP based web services and apps quickly.
4.middlewares : to extend core framework like - logging,database,security,templates...



Objects in express

1.Application
  We call Container object which other objects
  entry and exit of an application
  application is created by calling function

2.Request

3.Response

4.Router


1.Application object roll:

-Routing HTTP requests
-Configuring middleware
-Rendering HTML views
-Registering a template engine

...........................................................................................

How to create simple express app?

const express = require('express');
//console.log(express)

//create Application Object
const app = express();

//Routing : request Handling

app.get('/', (req, res) => {
    res.end('Home')
})

//start server
app.listen(3000, () => {
    console.log('express server is running!!');
})

Request Handling with Http Methods and url pattern
const express = require('express');
const app = express();

app.get('/', (req, res) => {
    res.end('Home')
})

//end points
app.get('/api/greet',(req,res)=>{
    res.end('greet')
})

app.get('/api/hello',(req,res)=>{
    res.end('hello')
})
app.get('/api/hai',(req,res)=>{
    res.end('hai')
})

app.post('/api/greet',(req,res)=>{
    res.end('greet -post')
})

app.put('/api/greet',(req,res)=>{
    res.end('greet -put')
})

app.delete('/api/greet',(req,res)=>{
    res.end('greet -delete')
})
//start server
app.listen(3000, () => {
    console.log('express server is running!!');
})

............................................................................................

JSON Data:
..........

const express = require('express');
const { findAll } = require('./services/todo.service')
//create Application Object
const app = express();

//Routing : request Handling

app.get('/', (req, res) => {
    res.end('Home')...........
})

app.get('/api/todos', async (req, res) => {
    try {
        const todos = await findAll();
        res.json(todos);
    }
    catch (err) {
        res.json({ err: err })
    }

});


//start server
app.listen(3000, () => {
    console.log('express server is running!!');
})
...............................................................................................

const express = require('express');
const { findAll } = require('./services/todo.service')
//create Application Object
const app = express();

//Routing : request Handling

app.get('/', (req, res) => {
    res.end('Home')
})

app.get('/api/todos', async (req, res) => {
    try {
        const todos = await findAll();
        res.json(todos);
    }
    catch (err) {
        res.json({ err: err })
    }

});
app.post('/api/todos/create', (req, res) => {

    let todo = '';
    req.on('data', chunk => {
        todo += chunk

    })

    req.on('end', async () => {
        try {
            console.log(todo);
            //how to send status code and response
            res.status(201).location("/api/todos/create").json({ message: 'Todo Created'})

        }
        catch (error) {
            res.status(404).json({ message: error })
        }
    });

});



 - plugins , can  be plugged into app - features adding


types of middlewares

1.built in middlewares
2.third party middlewares
3.custom middlewares.



Use case :
 How to read JSON input. Express server need to read json which was submitted by endusers 
User will submit as json --- express need to convert into javascript object.

Without Middleware :

1.we need to register data, end event for reading input
2.we need to convert input into javascript object - JSON.parse()


app.post('/api/todo', async (req, res) => {

    let todo = '';
    req.on('data', chunk => {
        todo += chunk
    })
    
    req.on('end', async() => {
        try {
            console.log(todo)
            const todos = await create(todo);
            res.status(201).location("/api/todo").json({ message: 'Todo Created' })
        }
        catch (error) {
            res.status(500).json({ message: error })
        }
    });

})

With Middleware :

-any middleware is simple javascript module/package only.
-most of the middlewares are community driven.
-if you want any middleware you need to install  

https://expressjs.com/en/resources/middleware.html

body-parser
Node.js body parsing middleware.

Parse incoming request bodies in a middleware before your handlers, available under the req.body property.

Parsers supported by body-parser Middleware:
.............................................

This module provides the following parsers:

1.JSON body parser
2.Raw body parser
3.Text body parser
4.URL-encoded form body parser

//start server
app.listen(3000, () => {
    console.log('express server is running!!');
})

Steps:

1.install middleware
$ npm install body-parser

2.Any Middleware must be registered with Application Object.
in order to activate middleware.

app.use(middleware)

const express = require('express');
const { findAll } = require('./services/todo.service')
const bodyParser = require('body-parser')
const morgan = require('morgan')
const fs = require('fs')
const path =require('path');



const app = express();


// create a write stream (in append mode)
const accessLogStream = fs.createWriteStream(path.join(__dirname, 'access.log'), { flags: 'a' })

// setup the logger
app.use(morgan('combined', { stream: accessLogStream }))
//Register Middleware: bodyParser
//Register middlewares
app.use(bodyParser.json())


///
app.get('/', (req, res) => {
    res.end('Home')
})

app.post('/api/todos/create', (req, res) => {

    try {
        const payload = req.body;
        console.log(payload)
        res.status(201).location("/api/todos/create").json({ payload })
    }
    catch (error) {
        res.status(500).json({ message: error })
    }
});


//start server
app.listen(3000, () => {
    console.log('express server is running!!');
})
..............................................................................................
				   Routing
..............................................................................................

const express = require('express');
const app = express();


app.get('/', (req, res) => {
    res.end('Home')
})

//Resource Greeter

app.get('/api/greeter/list',(req,res)=>{
    res.end('greeter-list')
})

app.get('/api/greeter/create',(req,res)=>{
    res.end('greeter-save')
})
//Resource todo
app.get('/api/todos/list',(req,res)=>{
    res.end('todos list')
})
app.get('/api/todos/create',(req,res)=>{
    res.end('todos list')
})
app.listen(3000, () => {
    console.log('express server is running!!');
})



if you look this code, we have to break into modules and separate out with routing.

............................................................................................
				Routing

src/app.js

const express = require('express');
const greeterRouter = require('./routers/greeter.router');
const todoRouter = require('./routers/todo.router')

const app = express();

//register routers with app 

app.use('/api/greeter', greeterRouter);
app.use('/api/todos', todoRouter);



app.get('/', (req, res) => {
    res.end('Home')
})

app.listen(3000, () => {
    console.log('express server is running!!');
})

src/routers/todo.router.js

const express = require('express');
//create Router Object
const todoRouter = express.Router()


//Resource todo
todoRouter.get('/list',(req,res)=>{
    res.end('todos list')
})
todoRouter.get('/create',(req,res)=>{
    res.end('todos save')
})
module.exports =todoRouter;

src/routers/greter.router.js

const express = require('express');
//create Router Object
const greeterRouter = express.Router()

//Resource Greeter

greeterRouter.get('/list', (req, res) => {
    res.end('greeter-list')
})

greeterRouter.get('/create', (req, res) => {
    res.end('greeter-save')
})

module.exports = greeterRouter;
...........................................................................................
				Micro Services
..........................................................................................

What is Micro Service?

Way of building distributed application.

Distributed App history and types:

1.IBM MainFrame based distributed app from 1970.
2.Client -Server - based on main frame and later micro computers.
3.Tiers of client -server
4. single tier client server
5.two tier client server
6.three tier client server

7.web based client server 
   Three or N client server

N tier web based client server architecture : Monolothic Architecture.

Technology stack could java(jee),.notdet,php........


How to build ,test,deploy monolithic client server distribute app?

-Technology first J2EE, Domain Next.

Team: OMS - PM- More PLS
1. DEV
2. TESTING
3. RELEASE
4. OPERATIONS

Project work flow

1.Req
2.Design
   High Level-UML,Database
   Low level - Runtime,databases,tools......
3.coding

-Vendor-lock in : Mono-lithic
   -DEV,TESTING,PRODUCTION.
-Work flow is highly sequencial
   Req -Complete
   Dev
   testing
   Release
   Production
  Delay in delivery:Cost increased
-Production cost was huge

Data Centers
 -need to purchase high powered servers - bare metal servers
 
Cost:
   -Hardware
   -OS -Linux-Ubuntu
   -Tools -Servers,databases etc....
   -Matrix Hell -  Mapping software components in dev and Production..

How to build enterprise jee based app.

App  must support a variety of different clients including desktop browsers. 

The application might also expose an API for 3rd parties to consume.

It might also integrate with other applications via a message broker. 

The application handles requests (HTTP requests and messages) by executing business logic; 

accessing a database; 
exchanging messages with other systems;

and returning a HTML/JSON/XML response. 

There are logical components corresponding to different functional areas of the application.

............................................................................................

IF App needs to talk to external systems like Message Brokers, other Systems like Main frames.

RPC/RPI
MOM
Connectors Arch.

BIZ LOGIC:

1- Service Layer : isloate service layer into separate component

 can be inside one app - one layer, that layer may run on different jvms -  distributed Arch.


Layer :

 Client ---- Web Layer  ----Service Layer ---- Repository Layer

////////////////////////////////////////////////////////////////////////////////////////////

Packaging Model:
 
WAR - Web archive
EAR .

Problems with Single JAR/WAR:

1. Scalability
 Vertical scablitity
 Horzitional scability 

2.Deployments
    -Bare Metal Deployment

////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////
Monoloith distributed app development drabackbacks:

-Time is taken for project delivery
   -Requirements 
   -High level design and low level design
   -coding
   -testing
   -release
   -production- live

-Technology Stack and Vendor lock in
   -You need to build the entire app using one technology or one vendor product
    eg: J2EE, Oracle,Weblogic

-Production and maintance cost
  -You need to setup large data centers , you need to maintain them.
..............................................................................................

    Companies like amzon,netflix,google wanted to change the app development model.
                                "Micro services"


Micro services are architural model of req,dev,test,relase,production,maintaince different ways.
    Continous req collecting
    Continous dev
    Continuous testing
    Continuous release
    Continuous deployment
    Using rented data centers: Cloud

-Domain First, Technology Next: Domain Driven Design.
-No Vendor lock- Multi tech stack.
-Indidual dev , deployment - orders is development ,tested,deployed,customers are developed,tested deployment.
   -Parrel dev.
-Automation -dev ops
   release - CI 
   deployment - Containerized - Docker..
-Introduction of Cloud computing
..............................................................................................
..............................................................................................

                                  Micro Services Design Pattern
..............................................................................................

Implementation Patterns:
........................

1.DOMAIN Models
  Decompose by biz features
  Decompose by sub domains

2.Development
  -Object oriented Design
 Class
      -Represent something in domain eg :Order,Customer
 Service
     -Offerings : giving something to somebody.
   A Program offers something - Data

Services can be broken into smllar and smallar based on domains
   Telecom domain :
       Telecommunication Services
		-Data Service
			- Mobile data
			- Broad Band
			    -Fiber
                            -leased Line
    
    FiberOpticService
        -getSpeed - 
        -increaseSpeed-
        -getNewConnection-
        -disconnectExisingConnection() 
        -payBills()    

   BillingService
	generateBill
	processPayment
	sendBill
        adjustBill
  
   How to design a Service? 
	USING SOLID Principles

  Single-responsibility principle -SRP

/////////////////////////////////////////////////////////////////////////////////////////////

Service Communications:
 
   Two Domains are going to collbrate each other to carry a biz transaction.


In Micro Services


FiberOpticService
     is 
   Running 
     inside
 One Application
       |
     Runtime
       |
  VM -Container

      OS
 
     |
     |   data
     |

Billing is Running
     is 
   Running 
     Another
 One Application
      |
     Runtime
       |
  VM -Container

      OS

Class ----will become  Objects

Object Communication === Service Communication



-SAME JVM(Runtime)
  Calling methods from one object(FiberDataService) to another object (BillingService).
-Different Runtime(JVM)
   -Networks - Protocals
    RestFull
      -HTTP 
   -RPC/RIP
	-ORB
        -RMI
        -gRpc
   -MOM - Message Brokers
        RabbitMQ
	Kaffka
	etc...
   -Event Bus
	-TCP

/////////////////////////////////////////////////////////////////////////////////////////////

Sevices Are Eagar or Lazy:
.........................
 

Eagar Service expects data immediatly.

Service waits for data until it is received.The service cant continue other jobs ; 

Sync Services

Drawbacks:

- Blocking 
    It leads performance issues

Service does not wait for data until it is received.The service t continue other jobs ; 

Async Services

Advantages
 - Non Blocking
    
Async Services Implementation:
..............................

Two ways:

1.Programmetic level 
    -Netty,webflux,Quarkus,Moleculre

2.Via Message Brokers
    RabbitMQ,Kafka


///////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////////////

Service Failures:
.................

1.UnAvailability

2.Timeout due to slow calls

How to handle failures , how to return proper response to caller?

Reliability Design patterns :fault tolerance 

 -Circuit Breaker
 -Bulk Head
 -Rate Limiter
 -Retry
 -TimeLitmiter
 -Cache

///////////////////////////////////////////////////////////////////////////////////////////


Service Communications in network and its Problems:
...................................................

Services are going to talk each other.

If they want to talk, What services should know each other?

 -Location
     ip address

In monolithic(traditional) deployment - ip address , ports are well known (hardcoded)
but in containers/ cloud env which are highly dynamic.

Where Micro services typically runs in a virtualized or containerized envs , locations are highly.

Services need to be registered some where and others services will ask registered location, that , hey give me that service

Service Registry and Discovery Pattern:
.......................................
Service Registry:
  -database - stores service informations

Service Discovery:
  locating services from the service registry

Types of Service discovery:
 -Client Side Service Discovery
 -Server Side Service Discovery
.............................................................................................
.............................................................................................

Data Management :

 A Service need to store data in data sources - Database
  
Database Per Service.

 FiberOpticService
Each service has its own schema. 
you can have more than one tables per service

Database: 
  Collection of tables,views,other objects

Shared Database:
  Sharing db for more than one services .
/////////////////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////////////////

Service Communication and Data Management

How to implement Transactions In Microservices?

It is very very difficult to implement and track transactions across multiple services.

Transactional Designpattern:

1.2PC  - 2 Phase Commit

2.Saga
    -EDA - Event Driven Architectures
  Saga Implementation
	-Choreography
        -Orchestration
//////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////

                           Micro Services Management Patterns
..........................................................................................

1.Log Managements
     Distributed/Centralized log management.
 
Tools:
   Graylog - mongodb,ES,Graylog
   ELK Stack  - ES,Logstash,kibana
   EFK Stack  - ES,Fluentd,Kibana


2.Application Metrics
     To monitor Application behaviours

Tools:
   Prometheus
   AWS Cloud Watch

3.Auditing
    User auditing,application auditing - Performance
    Record User activties in a databse

4.Distributed Tracing /Tracking
   If i want to track service calls
    A -->B ---C -- Something
   You can Track Exception Hierachies
  
 Open zipkin
 Open Tracing

5.Health Check Api
    To test health of apis,infra components.

 Some implemetations provides health endpoints where you can get helath metrics information
that can be feed to tools 

-Prometheus
.............................................................................................
				////////////////////////////////////////////////////////////////////////////////////////////
				Micro Services - Implementations
............................................................................................

Microservices is langugage,platform,os independant. 

Java:
 -Spring Cloud
 -Quarkus
 -Light4J
 -Vertx
 etc...

Javascript : nodejs

-  Moleculer
-  Seneca
-  Loop back
............................................................................................

                 		Moleculer

Progressive microservices framework for Node.js

Moleculer is framework which has implemented most of common microservices design patterns.

Moleculer features:

1.Promise-based solution (async/await compatible)
2.request-reply concept
3.support event driven architecture with balancing
4.built-in service registry & dynamic service discovery
5.load balanced requests & events (round-robin, random, cpu-usage, latency, sharding)
6.many fault tolerance features (Circuit Breaker, Bulkhead, Retry, Timeout, Fallback)
7.plugin/middleware system
8.support versioned services
9.support Streams
10.service mixins
11.built-in caching solution (Memory, MemoryLRU, Redis)
12.pluggable loggers (Console, File, Pino, Bunyan, Winston, Debug, Datadog, Log4js)
13.pluggable transporters (TCP, NATS, MQTT, Redis, NATS Streaming, Kafka, AMQP 0.9, AMQP 1.0)
14.pluggable serializers (JSON, Avro, MsgPack, Protocol Buffer, Thrift)
15.pluggable parameter validator
16.multiple services on a node/server
17.master-less architecture, all nodes are equal
18.parameter validation with fastest-validator
19.built-in metrics feature with reporters (Console, CSV, Datadog, Event, Prometheus, StatsD)
20.built-in tracing feature with exporters (Console, Datadog, Event, Jaeger, Zipkin)
21.official API gateway, Database access and many other modules…

.............................................................................................
Moleculer setup:

project creations;

1.from begining like normal node application.
2.moleculer cli- to setup realtime project with all artifacts.


1.create project from scratch.

create folder

mkdir microserviceapp

cd microservices/mkdir services

npm init
npm install moleculer
.............................................................................................
				Moleculer Architecture and Core concepts
.............................................................................................

1.Service:
  A Service is a simple java script module containing some part of a complex application.
  eg: UserService - contains information about users -  findAll users,save user,findBy,delete,update.
 It is isloated and self contained from the whole application, every service independant, meaning that even if the service goes offline or crashes the remaining services would be unaffected.

2.Node
   A node is simple os process(noderuntime). node may run local machine or external network.
   On a node one or more services are running.

3.Service Broker
   Service Broker is heart of moleculer.
   Service Broker is runtime for moleculer apps.
   Service Broker provides all infrastructure components - like    servicediscovery,loadbalancer,network transporters,message bus .... 

4.Transporter
   Transporter is communication bus that services are used to communicate across the network
   It can transfer message,events,request,response....

5.GateWay
    API Gateway exposes exposes moleculer services to end users.
   if external system/users who can communicate moleculer micro service apps via gate way only.


Services:

1.HTTP services
   Services are exposed for outsideworld - RestFull api

2.Back end services
   Services are used to encasulate biz logics like database operations,any biz



service names and file names:

math.service.js
hello.service.js


const { ServiceBroker } = require('moleculer');

//create broker object
const broker = new ServiceBroker();

//create service
//service takes service schema as parameter
broker.createService({
    name: 'hello',
    actions: {
        //biz methods- service methods
        sayHello() {
            return 'Hello Moleculer!'
        }
    }
})

//thenable pattern
function main() {
    broker.start()
        .then(() => {
            console.log('broker is ready')
            //call service 
            broker.call('hello.sayHello').then(res => {
                console.log(res);
            })
                .catch(err => {
                    console.log(err);
                });
        })
        .catch(err => console.log(err))
}
///async and await
async function init() {

    try {
        await broker.start()
        const res = await broker.call('hello.sayHello')
        console.log(res);
    }
    catch (err) {
        console.log(err);
    }

}
//main();
init();
.............................................................................................

multi methods and multiple services
....................................

const { ServiceBroker } = require('moleculer');

//create broker object
const broker = new ServiceBroker();

broker.createService({
    name:'greeter',
    actions: {
        //multiple methods
        sayHello(){
           return 'Hello'
        },
        sayHai() {
            return 'Hai'
        }
    }
})

broker.createService({
    name:'users',
    actions: {
        //multiple methods
        findAll(){
           return 'Users-all'
        },
        findById() {
            return 'Users by id'
        }
    }
})
async function init() {

    try {
        await broker.start()
        const hello = await broker.call('greeter.sayHello')
        const hai = await broker.call('greeter.sayHai')
        const findAll = await broker.call('users.findAll')
        const findById = await broker.call('users.findById')

        console.log(hello,hai,findAll,findById);
    }
    catch (err) {
        console.log(err);
    }

}
//main();
init();
............................................................................................

actions:
  Are used to represent methods.

Methods can be represented in two ways:

Way -1:
actions : {
 
  sayHello(){
     return 'hello'
  }

}

Way-2: you can add meta information to a methods

meta informations will discuss later.

actions: {
  
  sayHello: {
    
       handler(){
          
          return 'Hello'
           
       } 
  }

} 

broker.createService({
    name: 'orders',
    actions: {

        findAll: {
            //handler
            handler() {
                return 'Orders'
            }
        },
        create: {
            //handler
            handler() {
                return 'Orders create'
            }
        }
    }
})

async function init() {

    try {
        await broker.start()
        const hello = await broker.call('greeter.sayHello')
        const hai = await broker.call('greeter.sayHai')
        const findAll = await broker.call('users.findAll')
        const findById = await broker.call('users.findById')
        const orderFindall = await broker.call('orders.findAll')

        console.log(hello, hai, findAll, findById,orderFindall);
    }
    catch (err) {
        console.log(err);
    }

}
//main();
init();
..............................................................................................



broker.createService({
    name: 'hello',
    actions: {
        sayHello(ctx) {
            return 'Hello Service'
        }
    }
})

const hello = await broker.call('hello.sayHello',{name:'Subramanian'})

-Parameters must be encapsulated inside object only - {name:'subramanian'}

-Args must be received via one Object called "Context" Object

Context :

-it is proxy object for broker meaning that, similar broker.
-Most of the broker features are availble inside context object
-Context objects are created by moleculer automatically.
-We can grab context object reference inside actions method args
-Using context 
   -read parameters - ctx.params
   -you can call other service methods -  service communication. ctx.call
   -if you want to access broker information  inside service

const { ServiceBroker } = require('moleculer');

//create broker object
const broker = new ServiceBroker();

broker.createService({
    name: 'greeter',
    actions: {
        //biz methods- service methods
        sayHello(ctx) {
            console.log(ctx.params)
            return `Hello ${ctx.params.name}`
        },
        sayGreet: {
            handler(ctx) {
                const { name,message } = ctx.params;
                // return `Greet ${ctx.params.name}`
                return `${message} ${name}`;
            }
        }
    }
})
///async and await
async function init() {

    try {
        await broker.start()
        const res = await broker.call('greeter.sayHello', { name: 'Subramanian' })
        const greet = await broker.call('greeter.sayGreet', { name: 'Subramanian',message:'Hai' })

        console.log(res,greet);
    }
    catch (err) {
        console.log(err);
    }

}
init();
............................................................................................
				 Service Communication
..........................................................................................
	
Types of services:

1.Back End Services
2.Http Services

Two types of services based on communication.
1.local service

2.remote service

Back End Service Communication:
...............................
1.local service : 

 if services are running on single /same node/single broker - local services


const { ServiceBroker } = require('moleculer');

//create broker object
const broker = new ServiceBroker();

//math service
broker.createService({
    name: 'math',
    actions: {
        add: {
            handler(ctx) {
                const { a, b } = ctx.params
                //call adder service
                return ctx.call('adder.addNumbers', { a: a, b: b })
            }
        }
    }
})


//adder service
broker.createService({
    name: 'adder',
    actions: {
        addNumbers: {
            handler(ctx) {
                const { a, b } = ctx.params
                return a + b;
            }
        }
    }
})
async function init() {

    try {
        await broker.start()
        const res = await broker.call('math.add', { a: 10, b: 20 })
        console.log(res);
    }
    catch (err) {
        console.log(err);
    }

}
init();
..............................................................................................
				Params Validation -Moleculer uses validation framework
.............................................................................................

const { ServiceBroker } = require('moleculer');

//create broker object
const broker = new ServiceBroker();

//math service
broker.createService({
    name: 'math',
    actions: {
        add: {
            //meta information: validation
            params: {
                a: 'number',
                b: 'number'
            },
            handler(ctx) {
                const { a, b } = ctx.params
                //call adder service
                return ctx.call('adder.addNumbers', { a: a, b: b })
            }
        }
    }
})


//adder service
broker.createService({
    name: 'adder',
    actions: {
        addNumbers: {
            params: {
                a: 'number',
                b: 'number'
            },
            handler(ctx) {
                const { a, b } = ctx.params
                return a + b;
            }
        }
    }
})
async function init() {

    try {
        await broker.start()
        const res = await broker.call('math.add', { a: 10, b: 20 })
        console.log(res);
    }
    catch (err) {
        console.log(err);
    }

}
init();
............................................................................................
REPL: READ Evaulate Print Loop:
- interactive command line tool, used for testing application.

node provides REPL
node

Moleculer provides REPL Prompt for testing services interactivly.
Moleculer provides REPL Prompt for testing services interactivly.

services/math.service

const { ServiceBroker } = require('moleculer');

const broker = new ServiceBroker();

broker.createService({
    name: 'math',
    actions: {
        add: {
            params: {
                a: 'number',
                b: 'number'
            },
            handler(ctx) {
                const { a, b } = ctx.params
                return a + b;
            }

        }
    }
});

async function main() {
    try {
        await broker.start()
        broker.repl();        
    }
    catch (err) {
        console.log(err);
    }

}
main();



npm install moleculer-repl --save-dev

>node services/repl.service.js
[2021-07-24T09:34:52.394Z] INFO  laptop-r2tggfdl-6988/BROKER: Moleculer v0.14.16 is starting...
[2021-07-24T09:34:52.396Z] INFO  laptop-r2tggfdl-6988/BROKER: Namespace: <not defined>
[2021-07-24T09:34:52.397Z] INFO  laptop-r2tggfdl-6988/BROKER: Node ID: laptop-r2tggfdl-6988
[2021-07-24T09:34:52.398Z] INFO  laptop-r2tggfdl-6988/REGISTRY: Strategy: RoundRobinStrategy
[2021-07-24T09:34:52.399Z] INFO  laptop-r2tggfdl-6988/REGISTRY: Discoverer: LocalDiscoverer
[2021-07-24T09:34:52.407Z] INFO  laptop-r2tggfdl-6988/BROKER: Serializer: JSONSerializer
[2021-07-24T09:34:52.419Z] INFO  laptop-r2tggfdl-6988/BROKER: Validator: FastestValidator
[2021-07-24T09:34:52.421Z] INFO  laptop-r2tggfdl-6988/BROKER: Registered 13 internal middleware(s).
[2021-07-24T09:34:52.440Z] INFO  laptop-r2tggfdl-6988/REGISTRY: '$node' service is registered.
[2021-07-24T09:34:52.443Z] INFO  laptop-r2tggfdl-6988/REGISTRY: 'math' service is registered.
[2021-07-24T09:34:52.443Z] INFO  laptop-r2tggfdl-6988/$NODE: Service '$node' started.
[2021-07-24T09:34:52.444Z] INFO  laptop-r2tggfdl-6988/MATH: Service 'math' started.
[2021-07-24T09:34:52.445Z] INFO  laptop-r2tggfdl-6988/BROKER: ✔ ServiceBroker with 2 service(s) is started successfully in 13ms.
mol $ help

  Commands:

    help [command...]                                          Provides help for a given command.
    q                                                          Exit application
    actions [options]                                          List of actions
    bench [options] <action> [jsonParams] [meta]               Benchmark a service
    broadcast <eventName>                                      Broadcast an event
    broadcastLocal <eventName>                                 Broadcast an event locally
    cache keys [options]                                       List keys of cache entries
    cache clear [pattern]                                      Clear cache entries
    call [options] <actionName> [jsonParams] [meta]            Call an action
    dcall [options] <nodeID> <actionName> [jsonParams] [meta]  Direct call an action
    clear [pattern]                                            Clear cache entries
    cls                                                        Clear console
    destroy <serviceName> [version]                            Destroy a local service
    emit <eventName>                                           Emit an event
    env                                                        List of environment variables
    events [options]                                           List of event listeners
    info                                                       Information about broker
    load <servicePath>                                         Load a service from file
    loadFolder <serviceFolder> [fileMask]                      Load all services from folder
    metrics [options]                                          List metrics
    nodes [options]                                            List of nodes
    services [options]                                         List of services

mol $


Services:

-admin service
   services for monitoring moleculer application
$node

-application services
math,customer,user

call math.add --a 10 --b 20
>> Call 'math.add' with params: { a: 10, b: 20 }
>> Execution time:592μs
>> Response:
30
mol $ call math.add --a 10 --b 30
>> Call 'math.add' with params: { a: 10, b: 30 }
>> Execution time:653μs
>> Response:
40
mol $ call math.add --a 10 --b 390
>> Call 'math.add' with params: { a: 10, b: 390 }
>> Execution time:473μs
>> Response:
400
mol $ call math.add --a 100 --b 390
>> Call 'math.add' with params: { a: 100, b: 390 }
>> Execution time:551μs
>> Response:
490




.............................................................................................
				  Remote Services
............................................................................................


open two cmd
>node services/remote1.service.js
>node services/remote2.service.js

from remote1.service.js , invoke method from repl
 call math.add --a 10 --b 20
>> Call 'math.add' with params: { a: 10, b: 20 }
[2021-07-24T10:01:27.768Z] WARN  laptop-r2tggfdl-11112/BROKER: Service 'adder.add' is not registered.
>> ERROR:
ServiceNotFoundError: Service 'adder.add' is not found.
    at ServiceBroker.findNextActionEndpoint (C:\session\CYIENT\microserviceapp\node_modules\moleculer\src\service-broker.js:1034:13)
    at ServiceBroker.call (C:\session\CYIENT\microserviceapp\node_modules\moleculer\src\service-broker.js:1083:26)
    at Context.call (C:\session\CYIENT\microserviceapp\node_modules\moleculer\src\context.js:289:23)
    at Service.handler (C:\session\CYIENT\microserviceapp\services\remote1.service.js:15:28)
    at C:\session\CYIENT\microserviceapp\node_modules\moleculer\src\utils.js:185:22
    at processCheckResponse (C:\session\CYIENT\microserviceapp\node_modules\moleculer\src\validators\base.js:66:12)
    at validateContextParams (C:\session\CYIENT\microserviceapp\node_modules\moleculer\src\validators\base.js:84:15)
    at ServiceBroker.timeoutMiddleware (C:\session\CYIENT\microserviceapp\node_modules\moleculer\src\middlewares\timeout.js:35:14)
    at ServiceBroker.fallbackMiddleware (C:\session\CYIENT\microserviceapp\node_modules\moleculer\src\middlewares\fallback.js:29:11)
    at ServiceBroker.errorHandlerMiddleware (C:\session\CYIENT\microserviceapp\node_modules\moleculer\src\middlewares\error-handler.js:14:10)
Data:  { action: 'adder.add' }


-The moleculer not able to find out service from the local node, since it is running remotly
............................................................................................
.............................................................................................
				Networking
............................................................................................



In order to communicate with other nodes(serviceBrokers) you need to configure a transporter.


Transporters:

-Transporter is an important module if you are running services on multiple nodes. 

-Transporter communicates with other nodes. 

-It transfers events, calls requests and processes responses …etc. 

-If a service runs on multiple instances on different nodes, the requests will be load-balanced among live nodes.

Transports:
............

Built-in transporters

TCP transporter
NATS Transporter
Redis Transporter
MQTT Transporter
AMQP Transporter
Kafka Transporter
NATS Streaming (STAN) Transporter

..............................................................................................






















