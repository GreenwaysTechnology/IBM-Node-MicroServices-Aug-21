					Node.js	
..............................................................................................

Lab:
node
vscode
docker
...........................................................................................

What is Node.js?
 Node.js® is a JavaScript runtime built on Chrome's V8 JavaScript engine.

Java Script Runtime:
 -It is a Runtime to run javascript code.

Types of Javascript Runtime:

1.Embeded javascript Runtime
   The javascript runtime is embeded into browser 
Every WebBrowser has javascript runtime

1.1.Chrome - V8
What is V8?
V8 is Google’s open source high-performance JavaScript and WebAssembly engine, written in C++. It is used in Chrome and in Node.js.

1.2.SpiderMonkey 
	is Mozilla’s JavaScript and WebAssembly Engine, used in Firefox, Servo and various other projects. It is written in C++, Rust and JavaScript. 

1.3.ChakraCore
   Microsoft edge.

etc....

2.Standalone Javascript Runtime.

-V8
..............................................................................................

We have many javascript engine. Can we run javascript code on all javascript engines as it is?

95% is possible.

All javascript engines implements the spec called "ECMA" Specification.

ECMA is standard to define javascript language. 

We call 

ECMA - ES - 1.0
ES 2.0
ES 4.0
ES 5.0
ES 6.0
ES 7....

Most stable version is called -ES 5 AND ES 6
............................................................................................

What is Javascript?

 Javascript is a Programming language
 
 Javascript is object based,functional style, event driven programming language.


Object based vs object oriented:
................................

Object Oriented Principles:
...........................

1.Abstraction
2.Encapsulation
3.Hierarchy
4.Typing
5.Modularity
----------------------
6.Concurrency
7.Persistency


if any language follows all oo concepts, object oriented language.

if any language is not following any one of object oriented principle or paritially implements
that language is called as 'object based language'.


What type of apps you can build using js?
 Object based Language
............................................................................................
functional Programming:
  It is like object oriented programming. 
  It is based on mathmetics called "Lambda calculus".
FP =Lambda calculus

Javascript implements object concepts and functional programming concepts in one place.
Javascript is hybrid style language.
.............................................................................................

Why javascript was created?
  JS created for HTML Document creation,maniupulation  language inside browser :DOM Programming.

When js was created?

In 1996, js was created by Netscap communications.

When js came out for use?

1996 , JS submitted to ECMA Committe.

1997-> JAVA SCRIPT 1.0 -> es 1
es 3 -1999
es 4 -2006
es 5 -2007
es 6 -2012-2015. - ecma 2015
es6 7,8,9....
..............................................................................................

What type of apps i can build using javascript?

-Browser apps - DOM programming
-Server side apps - Web Applications- Node.js
-Mobile Apps 
-IOT Apps

Now javascript is every where.

.............................................................................................
Blocking and Non Blocking Async and Sync Programming:
.....................................................

What is blocking and  non blocking in general?

Blocking means the method/function blocks/pause/freeze the main process until it returns the data to the caller.

Blocking apis will stop the execution until the result is returned to the caller.

Blocking IO AND Non Blocking io?



File Descriptor:
................

-FD is a datastructure presented inside os kernal at very low level
-FD is mapper between os and hardware layer
-FD is entry and exit point of os.


Blocking IO Example: java:

import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;

public class CopyBytes {
    public static void main(String[] args) throws IOException {

        FileInputStream in = null;
        FileOutputStream out = null;

        try {
            in = new FileInputStream("xanadu.txt");
            out = new FileOutputStream("outagain.txt");
            int c;

            while ((c = in.read()) != -1) {
                out.write(c);
            }

	   //some other api call
	    myapi(); // will not be called until read operation and write operation is            completed

        } finally {
            if (in != null) {
                in.close();
            }
            if (out != null) {
                out.close();
            }
        }
    }
}
////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////

Blocking io means:

 Application process is waiting until data is read from the kernal.
 if data is availble inside application only, it will move the next cycle.

eg 
 in.read()| 1.5sec
 otherapi()-this method will be called after 1.5sec only.
............................................................................................

............................................................................................
				Multithreading and Networking
............................................................................................

Multi Threading and IO (Blocking IO):

In General application platforms(jvm,CLR)(process) is multi threaded.

WebServers and Web Containers for any technology(java,.net,python,php) are multi threaded.

Web Containers and Request handling:
...................................

Each Request is mapped with a single thread

Request Per Thread Model

100 request === 100 Threads

Eg:

1.client-1 asks 1 gb file from the web server

 client-----request-----|WebServer----create/use a thread --starts io operations
 client-----request-----|WebServer----create/use a thread --starts io operations
 client-----request-----|WebServer----create/use a thread --starts io operations
 client-----request-----|WebServer----create/use a thread --starts io operations
 client-----request-----|WebServer----create/use a thread --starts io operations
 client-----request-----|WebServer----create/use a thread --starts io operations

Threading Model:

 -  Each Request is assigned to thread

C10k : concurrently handling ten thousand connections

A web server should handle 10k connections at the same point of time(may be 1sc/1min)

C10k is one of the real time problem, expectation was if web server able to handle
10k connections, then it is good infra structure,so i dont need to add more machines.

How to reduce servers , how to utilize the existing hardware resouces.

               "The birth of non blocking technology" / How to reduce threads.


Problems of Multi Threaded Models:

1.Context Switch:
   - if a thread is assigned for a client request, that request takes more time to process.
 thread need to be paused.
    Moving a thread from sleep to running(active) --- active to sleep - ctx switch..

cpu takes much time on thread schduling, so it decreases the performance of the server.

2.memory
   Every thread eats upto 1MB of memory.

............................................................................................


Non Blocking io apis:

In 2000,Linux Operating system started providing, apis in order to perform non blocking io operation.

1.select

2.poll

Select vs poll.

3.epoll
What is epoll?

 Epoll is a program which monitors fd table.
 Fd table is array.
 epoll has a for loop which iterates fd table

 epollfd = epoll_create1(0);

infinit loop
 for(;;){
     read array(fd) entries from 0th index
     checks data availablity from the hardware
     if yes
	 copy data from the hardware to kernal buffer
     else
       move next index
      checks daa availablity from the hardware for 1st index.
    ....
    move until the last index.
   
 }


Steps:

1.thread starts  calling sys call for network io, while doing, it registers a handler function which will be used later by the thread.

2.thread gets control immediately since kernal relases the control

3.Thread starts processing other tasks

Kernal side

1. loop is running by watching fds

2. data is available

3. kernal copies data into buffer

4. kernal emits event

Application

4. Receive events process the event by assigning handler function.

5. Handler function gets called, send data to Caller(user).

.............................................................................................
				How node implements the nonblocking arch
..............................................................................................



Node.js:

-Multi platform(any os), non blocking ,event processing archiecture.
-Reduces more threads,having limited threads-single thread for event processing.
-Suitable for large network concurrency applications.

 1000 requests = 1 thread.
Node components:

V8:


libuv:
  libuv is a multi-platform support library with a focus on asynchronous I/O.
  libuv is collection of c apis for multiple operatings
    -libuv works with epoll in linux
    -libuv works with kqueue in mac/open bsd os
    -libuv works with iocp in windows

Features:

Full-featured event loop backed by epoll, kqueue, IOCP, event ports.
Asynchronous TCP and UDP sockets
Asynchronous DNS resolution
Asynchronous file and file system operations
File system events
ANSI escape code controlled TTY
IPC with socket sharing, using Unix domain sockets or named pipes (Windows)
Child processes
Thread pool
Signal handling
High resolution clock
Threading and synchronization primitives


libuv contains:

1. event loop thread:

  This is demaon thread, starts spinning for listening for incomming events from os kernal space.

2.Thread Pools
   libuv maintains set of threads other than event loop thread for doing "BLOCKING" IO operations.

Warining; 
   dont over use thread pools , because if use more threads from the thread poll then it impacts performance,memory...
   Dont block event loop thread.

////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////
                                NonBlocking and Async implementation
............................................................................................

In order to write non blocking  apps.

 -Language/Platform must provide high level apis
	 -Node provides lot of high level apis 
 -We need to provide listener function/callback function, for handling result

Listener function has two phases:

1.Function must be registered before calling kernal
   Registernation is based on event name.

2.Functions gets called by thread once the event is given

Every listener function is higher order function : Function as parameter.


How javascript /node understands that programs need proceed by event loops thread.
what are blocking api and what are non blocking api.

->All apis are generally blocking except apis which binds with non blocking apis.

eg:
 console.log() - blocking

Node provides non blocking category of apis

1.timers

2.General fs io apis

3.all network api
   http,tcp,udp


All non blockings are powered "handler/callback/listener" functions.

Listener functions are generally higher order function: Passed as parameter.


Non blocking coding Styles:

Note: All are same but just wrappers on top that.

1.callback style /listener

2.Promise style : wrapper for callbacks

3.async functions and await : wrapper for promise.



Common Non Blocking Apis provided by node

1.timers
2.file system apis
3.networking apis
etc....
..........................................................................................
src/index.js

console.log('Hello Node');

how to run?

C:\session\ibm\2021\aug\apps\mynodeapp> node src/index.js
Hello Node

...........................................................................................

Functions declaration,invocation:
//higher order function -  listner pattern

function sayHello() {
    console.log('Hello')
}
sayHello();
//parameters and args

//a and b are args
function add(a = 0, b = 0) {
    return a + b;
}
//1 , 2 are parameters
console.log(add(1, 2))
console.log(add()) //undefined,undefined
/////////////////////////////////////////////////////////////////////////////////////
//Function is first class citzien -  function can be stored inside variable,passed around.

//var ,let ,const - variable declaration

var i = 10; // es 5 style
let j = 100; // es 6 style
const e = 100; // es 6 style

console.log(i, j, e)

i = 900;
j = 89;
// e =900;

console.log(i, j, e)

//anonmous function
let greet = function (name = 'default') {
    console.log('greet', name)
};
greet();
greet('Subramanian')

//arrow function. anonmous function in es 6
let hai = (name = 'default') => {
    console.log('greet', name)
};
hai();

//if function has only one line of body ,we can remove  {}
hai = (name = 'default') => console.log('greet', name);
hai();

//arrow and return

let multiply = (a = 0, b = 0) => {
    return a * b;
}
console.log(multiply(10, 10))

//if function has only one line of body with return statement, we can remove return and {}

multiply = (a = 0, b = 0) => a * b;
console.log(multiply(10, 10))

//one parameter , no default value and return the same. we can remove () and {} and return statement
let echo = message => message

console.log(echo("Hello Echo"))
..............................................................................................

Higher order function:
  function itself is value, so can be passed as parameter to another function that function is called higher order function.

function parameter can be any literal(values).

types of literals

1.string
2.number
3.boolean
4.undefined
5.nan
6.infinity
7.null
8.function
9.object

//Higher order function


function doStuff(a) {
    console.log(a)
}

//we can pass any literal as parameter
doStuff(10)
doStuff("hello")
doStuff(true)
let x = 10;
doStuff(x)
//pass function as parameter

//now connect is higher order
function connect(action) {
    console.log(action);
    action(); //invocation 
}
//pass function as parameter
let myFun = function () {
    console.log('myFun')
}
connect(myFun);

connect(function () {
    console.log('my fun anonmous')
});

//arrow
let myconnect = action => {
    console.log(action);
    action(); //invocation 
};

let myFun1 = () => console.log('myFun-arrow');
myconnect(myFun1);

myconnect(() => console.log('my fun anonmous-arrow'));

..............................................................................................


Advanced Higher order function:


let getMessage = action => {
    action('Hello');
}
getMessage(message => console.log(message));

//complex function

let login = (userName, password, successAction, failureAction) => {
    //logic
    if (userName === 'admin' && password === 'admin') {
        successAction('login success')
    } else {
        failureAction('login failed')
    }
}
login('admin', 'admin', status => { console.log(status) }, err => { console.log(err) })
login('foo', 'bar', status => { console.log(status) }, err => { console.log(err) })

...........................................................................................

How to write blocking code?

//blocking /sequencial code

function sayHello() {
    console.log('hello')
}
function sayHai() {
    console.log('hai')
}
function sayGreet() {
    console.log('greet')
}

sayHello(); 
sayHai();
sayGreet();


How to write non blocking code 

--code will not stop executing next line of code.
-->once result is availble only the function gets called -  callback function/listner function.
--> we need to schudule the code in the background(kernal space)- we need non blocking high level api from js/node.

How to write callback functions?
 -higher order function

Common Non Blocking Apis provided by node

1.timers
2.file system apis
3.networking apis
etc....

1.timers

setTimeout,setInterval,setImmediate...


//non blocking using timer

function blockMe(message) {
    console.log(message);
}
//non blocking function
function delay(action) {
    //high level api to schdule the task in the background
    setTimeout(action, 5000, 'Hello!!!')
}

//
blockMe('start')
delay(response=>console.log(response));
blockMe('end')
blockMe('still going')

callback Programming:
....................

passing function as parameter , gets called after getting event.
............................................................................................
..............................................................................................
					Nested Callbacks
..............................................................................................

 The output of one callback, will be input to another callback.

Use case

 - call getUser api, which returns user if not , throw error.

 - Based on user i need to call login method, if login failed throw error

 - Based on login output, i need to call dashboard

/**
 * getUser--->login--->showPage--->Display result
 * 
 * resolve=SuccessAction
 * reject =FailureAction
 */

const getUser = (resolve, reject) => {
    //logic
    let user = {
        name: 'admin',
        password: 'admin'
    };
    //  user = null;
    let error = {
        code: 500,
        message: 'User not found'
    }
    if (user) {
        setTimeout(resolve, 1000, user);
    } else {
        setTimeout(reject, 1000, error);
    }
}

const login = (user, resolve, reject) => {

    let status = 'login success';
    let error = 'login failed';

    if (user.name === 'admin' && user.password === 'admin') {
        setTimeout(resolve, 1000, status)
    } else {
        setTimeout(reject, 1000, error);
    }
}

const showPage = (status, resolve, reject) => {
    let successPage = 'Welcome to Prime Account';
    let failurePage = 'Welcome to Guest Account'

    if (status === 'login success') {
        setTimeout(resolve, 1000, successPage)
    } else {
        setTimeout(reject, 1000, failurePage)

    }


}

getUser(user => {
    console.log(user)
    login(user, status => {
        console.log(status)
        showPage(status, spage => {
            console.log(spage)
        }, epage => {
            console.log(epage);
        })
    }, err => {
        console.log(err);
    })
}, err => {
    console.log(err)
});


The Problems of Nested Callbacks:
................................

Questions:

1.Whether this code is able to understand quickly
2.Whether this code is able to debug
3.Whehter this code is scalable?
4.whether this code is maintaiable?

fs.readdir(source, function (err, files) {
  if (err) {
    console.log('Error finding files: ' + err)
  } else {
    files.forEach(function (filename, fileIndex) {
      console.log(filename)
      gm(source + filename).size(function (err, values) {
        if (err) {
          console.log('Error identifying file size: ' + err)
        } else {
          console.log(filename + ' : ' + values)
          aspect = (values.width / values.height)
          widths.forEach(function (width, widthIndex) {
            height = Math.round(width / aspect)
            console.log('resizing ' + filename + 'to ' + height + 'x' + height)
            this.resize(width, height).write(dest + 'w' + width + '_' + filename, function(err) {
              if (err) console.log('Error writing file: ' + err)
            })
          }.bind(this))
        }
      })
    })
  }
})

"Callback Hell":
................

 -It is not bug or error in code
 -It is way of writing callback based program
 -Callback based non blocking programming hard to understand,maintain,debug,scale Which 
  called as "Callback Hell".

How to write better async/non blocking code without writings callbacks?

-Generally without callbacks not possible to write async/non blocking code.
-Rather we can abstract complexity of writting callbacks.

In 2005, JQUERY team started with working complex callback patterns, they found callback hell problem.

They proposed a  Design pattern to write better callback programming(Async) programming.

  "Promise".

Promise is design pattern which hides complexity of callback patterns


Since Promise is design pattern, many people have implemented Promise design pattern.

1.JQuery -first promise implementation
2.many libs and frameworks


...........................................................................................

In order standarize , ECMA committe decided to include Promise Design pattern at language level .(ES 6)
2012 E6 Commit introduced promise design pattern  as  "Promise" Object  in javascript.



Promises and non blocking,async and callback hell issues:
.........................................................

features of Promise Object:

1.Promise by deafult is Async. Which implements timer api with 0 ms .

Promise can be used with any async callback based  implementations.


Objective:

 To remove callbacks in async/non blocking code. write cleaner async programming.
 To remove complex callback chaining code.
.............................................................................................


Promise Implemenation:How to create Promise Object

1. Create Promise Object from Promise contructor -  new Promise()
2. Create Promise object from factory apis       - Promise.resolve(), Promise.reject()

Promise object methods:
1.then - success
2.catch - errors
3.finally - clean up
factory api to create Promise object
4.resolve
5.reject
.......................................
6.all
7.race

............................................................................................

Promise with only success 

//Promise : How to create Promise Object, how to subscribe the 

function blockMe(message) {
    console.log(message);
}

//factory pattern
function getSuccess(){
    return Promise.resolve('Success');  // Promise Object with setTimeout of 0ms
}

blockMe('start')
// let mypromise= getSuccess()
// mypromise.then(res=>console.log(res))
getSuccess()
 .then(res=>console.log(res))
blockMe('end')
..............................................................................................
Catch Error:

//Promise : How to create Promise Object, how to subscribe the 

function blockMe(message) {
    console.log(message);
}

//factory pattern
function getFailure(){
    return Promise.reject('Something Went Wrong');  // Promise Object with setTimeout of 0ms
}

blockMe('start')
getFailure()
 .catch(err=>console.log(err))
blockMe('end')
.............................................................................................

How to handle success and failure based on biz logic.

const login = (userName, password) => {
    if (userName === 'admin' && password === 'admin') {
        return Promise.resolve('Login Success');
    } else {
        return Promise.reject('Login Failed')
    }
}

login('admin', 'admin')
    .then(res => console.log(res))
    .catch(err => console.log(err));
login('foo', 'admin')
    .then(res => console.log(res))
    .catch(err => console.log(err))

.............................................................................................
Promise with Constructor Pattern:

When we can select Constructor pattern?

-if i want to convert existing callback based code into promise 
-Incase if you are using timer with explicit timeout like 1000,5000 -  i want use setTimeout

new Promise()
     |
  constructor call

eg :

function Employee(){} - es 5 classes

class Employee {} -  es 6 class Syntax 

new Employee()
new Product()

Promise Constructor takes parameter which is function.

Parameter function takes two args 
 first arg represents success(resolve)
 second arg represents failure(reject)

new Promise(function(resolve,reject) {
  //function body - logic
   
})

function body has logic which is async code.

new Promise(function(resolve,reject) {
  //function body - logic
   setTimeout(resolve,5000,'data')
})

new Promise((resolve,reject)=> {
  //function body - logic
   setTimeout(resolve,5000,'data')
})
...........................................................................................

//promise constructors

function blockMe(message) {
    console.log(message);
}
function delay() {
    return new Promise((resolve, reject) => {
        setTimeout(resolve, 5000, 'Success Info')
    });
}

blockMe('start')
delay()
  .then(res=>console.log(res))
  .catch(err=>console.log(err));
blockMe('end')
.............................................................................................

PromiseConstructors with biz logic:

const login = (userName, password) => {
    return new Promise((resolve, reject) => {
        if (userName === 'admin' && password === 'admin') {
            setTimeout(resolve, 5000, 'Login success')
        } else {
            setTimeout(reject, 5000, 'Login Failed')
        }
    })


}

login('admin', 'admin')
    .then(res => console.log(res))
    .catch(err => console.log(err));
login('foo', 'admin')
    .then(res => console.log(res))
    .catch(err => console.log(err))
.............................................................................................

how to fix Callback hell using promises?


const getUser = () => {

    console.log('get user is called')
    //logic
    let user = {
        name: 'admin',
        password: 'admin'
    };
    //  user = null;
    let error = {
        code: 500,
        message: 'User not found'
    }
    return new Promise((resolve, reject) => {
        if (user) {
            setTimeout(resolve, 1000, user);
        } else {
            setTimeout(reject, 1000, error);
        }
    })
}

const login = user => {
    console.log('login is called')

    let status = 'login success';
    let error = 'login failed';
    return new Promise((resolve, reject) => {
        if (user.name === 'admin' && user.password === 'admin') {
            setTimeout(resolve, 1000, status)
        } else {
            setTimeout(reject, 1000, error);
        }
    });

}

const showPage = (status) => {
    console.log('show page is called')

    let successPage = 'Welcome to Prime Account';
    let failurePage = 'Welcome to Guest Account'
    return new Promise((resolve, reject) => {
        if (status === 'login success') {
            setTimeout(resolve, 1000, successPage)
        } else {
            setTimeout(reject, 1000, failurePage)

        }
    });
}

// getUser(user => {
//     console.log(user)
//     login(user, status => {
//         console.log(status)
//         showPage(status, spage => {
//             console.log(spage)
//         }, epage => {
//             console.log(epage);
//         })
//     }, err => {
//         console.log(err);
//     })
// }, err => {
//     console.log(err)
// });

// getUser()
//     .then(user => {
//         console.log(user)
//         login(user)
//             .then(status => {
//                 console.log(status)
//                 showPage(status)
//                     .then(spage => {
//                         console.log(spage)
//                     })
//                     .catch(epage => console.log(epage))
//             })
//             .catch(err => console.log(err))
//     })
//     .catch(err => console.log(err));

//The refactored promise code.

// getUser()
//     .then(user => {
//         console.log(user);
//         return login(user)
//     })
//     .then(status => {
//         console.log(status)
//         return showPage(status);
//     })
//     .then(page => {
//         console.log(page);
//     })
//     .catch(err => console.log(err));

//Es6 refactoring

getUser()
    .then(user =>login(user))
    .then(status =>showPage(status))
    .then(page =>console.log(page))
    .catch(err => console.log(err));
............................................................................................
				async and await
.............................................................................................

async and await are keywords to simplify promise handling -  without "thenables"

If code grows with many promises, you can see more "thenables",Which leads the problem called
"Promise Hell".

Promise Hell:

 In large code base, you can see many "thenables", how to reduce thenables.

ES 7 introduced even simple keywords , looks like sync program/sequencial call.
			"Sync style of async programm"

"async function and await keyword".



function delay() {
    return new Promise((resolve, reject) => {
        setTimeout(resolve, 1000, 'Hello!');
    })
}

//delay()

async function main() {
    //    delay()
    //     .then(res=>console.log(res))

    try {
        const res = await delay();
        console.log(res);
    } catch (err) {
        console.log(err);
    }

}
main();
.............................................................................................
Complex async and await:


const getUser = () => {

    console.log('get user is called')
    //logic
    let user = {
        name: 'admin',
        password: 'admin'
    };
    //  user = null;
    let error = {
        code: 500,
        message: 'User not found'
    }
    return new Promise((resolve, reject) => {
        if (user) {
            setTimeout(resolve, 1000, user);
        } else {
            setTimeout(reject, 1000, error);
        }
    })
}

const login = user => {
    console.log('login is called')

    let status = 'login success';
    let error = 'login failed';
    return new Promise((resolve, reject) => {
        if (user.name === 'admin' && user.password === 'admin') {
            setTimeout(resolve, 1000, status)
        } else {
            setTimeout(reject, 1000, error);
        }
    });

}

const showPage = (status) => {
    console.log('show page is called')

    let successPage = 'Welcome to Prime Account';
    let failurePage = 'Welcome to Guest Account'
    return new Promise((resolve, reject) => {
        if (status === 'login success') {
            setTimeout(resolve, 1000, successPage)
        } else {
            setTimeout(reject, 1000, failurePage)

        }
    });
}

async function main() {
    // getUser()
    // .then(user =>login(user))
    // .then(status =>showPage(status))
    // .then(page =>console.log(page))
    // .catch(err => console.log(err));

    try {
        const user = await getUser();
        const status = await login(user);
        const page = await showPage(status);
    }
    catch(err){
        console.log(err);
    }

}
main()
.............................................................................................
					Modularity:
.............................................................................................

What is Modularity?
  Breaking application into smaller units.

Types of Modularity?

1.Physicall modularity
  
  folders,files :  code is kept/organized into files and folders

2.Logical modularity
  code is kept into classes,functions,objects

Java:

 folders/files
  com/ibm/util/Utility.java

 package com.ibm.util

 class Utility{

 }



What about javascript Modularity?

1.Physicall modularity
   fodlers/file based
   scripts/index.js
2.logical modularity
  js does not offer logical modularity at language level.

Once js started growing in large scale, dev struck to organize code.

2000, Smart developers started thinking about how to modualrize js code.

Module design patterns came.

1.Namespace design pattern : 2000 : jquery implemented this design pattern in 2005
2.AMD -Async Module Defintion : dojo implemented amd design pattern 
---------------------------------------------------------
3.CJS - Common JS =  namespace + amd -2005
4.ES 6 Module design pattern  = amd + cjs - 2012 ECMA Committe introduced this pattern
------------------------------------------------------------
5.System = AMD = CJS + ES 6
6.UMD = NAMESPACE + AMD + CJS + ES 6


only two design patterns are used in development

1.CJS - Common JS =  namespace + amd
2.ES 6 Module design pattern  = amd + cjs

CJS ; implemented inside node js. node supports commonjs by default.

I can organize the code , based on these patterns, but what about runtimes?

  js runtime never suppport these patterns directly 
  each design pattern is lib.

 Loaders : it is simple js lib to help link and load js files.

Node.js has built in cjs loader and linker, so we dont need to install loaders
Browers has no built in support for any modular design pattern natively except , namespace.

////////////////////////////////////////////////////////////////////////////////////////////
				COMMONJS - Nodejs
////////////////////////////////////////////////////////////////////////////////////////////

Two important task in modules:

1.how to link files

  We need loaders and linkers - node.js provides by default
eg
java : import 

cjs : require('fileNametoBelinked')

Use case 1 : how to link files 

src/mylib.js
console.log('mylib')

src/index.js
const res = require('./mylib')

$node src/index.js
mylib


2.how to share code

What is code , What code can be shared to other files.

code : collection of variables,functions,classes,objects,arrays.

Ways of code sharing:

1.Pack the code into one object(literal) which you want to share

-exports
   -used to share code in form of object
   -code is packed inside object and shared that object
-module.exports
   -used to share code as it is.




src/mycode.js

//share code : variables having any value,functions,classes,objects,arrays

//pack the code into object using exports keyword
//exports.variable =value

exports.firstName = 'Subramanian'
exports.lastName = 'Murugan';
exports.age = 40
exports.isActive = true;
exports.calculate = function () {
    return 10;
}
exports.skills = ['javascript', 'node', 'java'];
exports.address = {
    city: 'Coimbatore',
    state: 'Tamil Nadu'
}

src/index.js
const info = require('./mycode')
console.log(info);

console.log(info.firstName,info.lastName,info.age)
console.log(info.address.city,info.address.state)
console.log(info.skills)
console.log(info.calculate())
..........................................................................................
module.exports:
..............

   -used to share code as it is.

When to use module.exports?

-to share single class
-to share single function
-to share single array
-to share any single variable,object



src/greeter.js


class Greeter {
    constructor() {

    }
    sayHello(name = '') {
        return `Hello ${name}`
    }
}

//share the class
module.exports = Greeter;

src/index.js
const Greeter = require ('./greeter');
console.log(Greeter)

let greet = new Greeter();

console.log(greet.sayHello('Subramanian'))
..............................................................................................

Returning object 


const Greeter = require ('./greeter');
const product = require('./product')

console.log(Greeter)

let greet = new Greeter();

console.log(greet.sayHello('Subramanian'))
console.log(product.findAll())

src/product.js


class Product {
    constructor(){
    
    }
    findAll(){
        return 'products'
    }
}

module.exports = new Product();
..............................................................................................

folders and file structures:
.............................

Objective:
 Build api

src
 |
 services
 mock-data
 app.js


src/services/todo.service.js
const TODOS = require('../mock-data/todo')

class TodoService {
    constructor() {

    }
    //sync api
    findAll() {
        return TODOS;
    }

    findAllAsyncCb(callback) {
        setTimeout(callback, 5000, TODOS);
    }

    findAllAsyncPromise() {
        return new Promise((resolve, reject) => {
            setTimeout(resolve, 5000, TODOS);
        })
    }

    getCompletedTodos() {
        return TODOS.filter(todo => todo.completed)
    }
}
module.exports = new TodoService();

src/app.js
const todoservice = require('./services/todo.service');


async function main() {
    //console.log(todoservice.findAll());
    // console.log(todoservice.getCompletedTodos())
    // console.log('start')
    //  todoservice.findAllAsyncCb(todos=>{
    //      console.log(todos);
    //  })
    // todoservice.findAllAsyncPromise()
    //     .then(todos => console.log(todos));

    const todos = await todoservice.findAllAsyncPromise();
    console.log(todos);
    // console.log('end')
}
main();

src/mock-data/todo.js

please refer code 
..............................................................................................
//////////////////////////////////////////////////////////////////////////////////////////////						Node.js api modules
..............................................................................................


Types of modules:

1.Custom modules
  built by us
2.Built in modules
   provided by node.js  
3.Third party modules-Provided by third party/community
  libs,frameworks -eg React,angular,Vue,express,jquery..............
..............................................................................................
Node js Built in modules:
.........................

-os
-events
-fs
-http
............................................................................................




